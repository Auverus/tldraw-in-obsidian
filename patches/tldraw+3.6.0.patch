diff --git a/node_modules/tldraw/dist-esm/index.d.mts b/node_modules/tldraw/dist-esm/index.d.mts
index f569ac0..c48e2e6 100644
--- a/node_modules/tldraw/dist-esm/index.d.mts
+++ b/node_modules/tldraw/dist-esm/index.d.mts
@@ -49,6 +49,7 @@ import { TLArrowShapeArrowheadStyle } from '@tldraw/editor';
 import { TLArrowShapeProps } from '@tldraw/editor';
 import { TLAsset } from '@tldraw/editor';
 import { TLAssetId } from '@tldraw/editor';
+import { TLAssetStore } from '@tldraw/editor';
 import { TLBookmarkShape } from '@tldraw/editor';
 import { TLBookmarkShapeProps } from '@tldraw/editor';
 import { TLClickEventInfo } from '@tldraw/editor';
@@ -1844,6 +1845,10 @@ export declare interface TldrawImageProps extends TLImageExportOptions {
      * The license key.
      */
     licenseKey?: string;
+    /**
+     * How should this store resolve assets?
+     */
+    assets?: TLAssetStore;
     /**
      * Asset URL overrides.
      */
diff --git a/node_modules/tldraw/dist-esm/lib/TldrawImage.mjs b/node_modules/tldraw/dist-esm/lib/TldrawImage.mjs
index cb23238..200b531 100644
--- a/node_modules/tldraw/dist-esm/lib/TldrawImage.mjs
+++ b/node_modules/tldraw/dist-esm/lib/TldrawImage.mjs
@@ -23,7 +23,11 @@ const TldrawImage = memo(function TldrawImage2(props) {
     () => [...defaultBindingUtils, ...bindingUtils],
     [bindingUtils]
   );
-  const store = useTLStore({ snapshot: props.snapshot, shapeUtils: shapeUtilsWithDefaults });
+  const store = useTLStore({
+    assets: props.assets,
+    snapshot: props.snapshot,
+    shapeUtils: shapeUtilsWithDefaults
+  });
   const assets = useDefaultEditorAssetsWithOverrides(props.assetUrls);
   const { done: preloadingComplete, error: preloadingError } = usePreloadAssets(assets);
   const {
diff --git a/node_modules/tldraw/dist-esm/lib/TldrawImage.mjs.map b/node_modules/tldraw/dist-esm/lib/TldrawImage.mjs.map
index 8d061ae..adc100b 100644
--- a/node_modules/tldraw/dist-esm/lib/TldrawImage.mjs.map
+++ b/node_modules/tldraw/dist-esm/lib/TldrawImage.mjs.map
@@ -1,7 +1,7 @@
 {
   "version": 3,
   "sources": ["../../src/lib/TldrawImage.tsx"],
-  "sourcesContent": ["import {\n\tDefaultSpinner,\n\tEditor,\n\tErrorScreen,\n\tLoadingScreen,\n\tTLAnyBindingUtilConstructor,\n\tTLAnyShapeUtilConstructor,\n\tTLEditorSnapshot,\n\tTLImageExportOptions,\n\tTLPageId,\n\tTLStoreSnapshot,\n\tuseShallowArrayIdentity,\n\tuseTLStore,\n} from '@tldraw/editor'\nimport { memo, useLayoutEffect, useMemo, useState } from 'react'\nimport { defaultBindingUtils } from './defaultBindingUtils'\nimport { defaultShapeUtils } from './defaultShapeUtils'\nimport { TLUiAssetUrlOverrides } from './ui/assetUrls'\nimport { usePreloadAssets } from './ui/hooks/usePreloadAssets'\nimport { getSvgAsImage } from './utils/export/export'\nimport { useDefaultEditorAssetsWithOverrides } from './utils/static-assets/assetUrls'\n\n/** @public */\nexport interface TldrawImageProps extends TLImageExportOptions {\n\t/**\n\t * The snapshot to display.\n\t */\n\tsnapshot: Partial<TLEditorSnapshot> | TLStoreSnapshot\n\n\t/**\n\t * The image format to use. Defaults to 'svg'.\n\t */\n\tformat?: 'svg' | 'png'\n\n\t/**\n\t * The page to display. Defaults to the first page.\n\t */\n\tpageId?: TLPageId\n\n\t/**\n\t * Additional shape utils to use.\n\t */\n\tshapeUtils?: readonly TLAnyShapeUtilConstructor[]\n\t/**\n\t * Additional binding utils to use.\n\t */\n\tbindingUtils?: readonly TLAnyBindingUtilConstructor[]\n\t/**\n\t * The license key.\n\t */\n\tlicenseKey?: string\n\t/**\n\t * Asset URL overrides.\n\t */\n\tassetUrls?: TLUiAssetUrlOverrides\n}\n\n/**\n * A renderered SVG image of a Tldraw snapshot.\n *\n * @example\n * ```tsx\n * <TldrawImage\n * \tsnapshot={snapshot}\n * \tpageId={pageId}\n * \tbackground={false}\n *  darkMode={true}\n *  bounds={new Box(0,0,600,400)}\n *  scale={1}\n * />\n * ```\n *\n * @public\n * @react\n */\nexport const TldrawImage = memo(function TldrawImage(props: TldrawImageProps) {\n\tconst [url, setUrl] = useState<string | null>(null)\n\tconst [container, setContainer] = useState<HTMLDivElement | null>(null)\n\n\tconst shapeUtils = useShallowArrayIdentity(props.shapeUtils ?? [])\n\tconst shapeUtilsWithDefaults = useMemo(() => [...defaultShapeUtils, ...shapeUtils], [shapeUtils])\n\tconst bindingUtils = useShallowArrayIdentity(props.bindingUtils ?? [])\n\tconst bindingUtilsWithDefaults = useMemo(\n\t\t() => [...defaultBindingUtils, ...bindingUtils],\n\t\t[bindingUtils]\n\t)\n\tconst store = useTLStore({ snapshot: props.snapshot, shapeUtils: shapeUtilsWithDefaults })\n\n\tconst assets = useDefaultEditorAssetsWithOverrides(props.assetUrls)\n\tconst { done: preloadingComplete, error: preloadingError } = usePreloadAssets(assets)\n\n\tconst {\n\t\tpageId,\n\t\tbounds,\n\t\tscale,\n\t\tpixelRatio,\n\t\tbackground,\n\t\tpadding,\n\t\tdarkMode,\n\t\tpreserveAspectRatio,\n\t\tformat = 'svg',\n\t\tlicenseKey,\n\t} = props\n\n\tuseLayoutEffect(() => {\n\t\tif (!container) return\n\t\tif (!store) return\n\t\tif (!preloadingComplete) return\n\n\t\tlet isCancelled = false\n\n\t\tconst tempElm = document.createElement('div')\n\t\tcontainer.appendChild(tempElm)\n\t\tcontainer.classList.add('tl-container', 'tl-theme__light')\n\n\t\tconst editor = new Editor({\n\t\t\tstore,\n\t\t\tshapeUtils: shapeUtilsWithDefaults,\n\t\t\tbindingUtils: bindingUtilsWithDefaults,\n\t\t\ttools: [],\n\t\t\tgetContainer: () => tempElm,\n\t\t\tlicenseKey,\n\t\t})\n\n\t\tif (pageId) editor.setCurrentPage(pageId)\n\n\t\tconst shapeIds = editor.getCurrentPageShapeIds()\n\n\t\tasync function setSvg() {\n\t\t\tconst svgResult = await editor.getSvgString([...shapeIds], {\n\t\t\t\tbounds,\n\t\t\t\tscale,\n\t\t\t\tbackground,\n\t\t\t\tpadding,\n\t\t\t\tdarkMode,\n\t\t\t\tpreserveAspectRatio,\n\t\t\t})\n\n\t\t\tif (svgResult && !isCancelled) {\n\t\t\t\tif (format === 'svg') {\n\t\t\t\t\tif (!isCancelled) {\n\t\t\t\t\t\tconst blob = new Blob([svgResult.svg], { type: 'image/svg+xml' })\n\t\t\t\t\t\tconst url = URL.createObjectURL(blob)\n\t\t\t\t\t\tsetUrl(url)\n\t\t\t\t\t}\n\t\t\t\t} else if (format === 'png') {\n\t\t\t\t\tconst blob = await getSvgAsImage(editor, svgResult.svg, {\n\t\t\t\t\t\ttype: format,\n\t\t\t\t\t\twidth: svgResult.width,\n\t\t\t\t\t\theight: svgResult.height,\n\t\t\t\t\t\tpixelRatio,\n\t\t\t\t\t})\n\t\t\t\t\tif (blob && !isCancelled) {\n\t\t\t\t\t\tconst url = URL.createObjectURL(blob)\n\t\t\t\t\t\tsetUrl(url)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\teditor.dispose()\n\t\t}\n\n\t\tsetSvg()\n\n\t\treturn () => {\n\t\t\tisCancelled = true\n\t\t}\n\t}, [\n\t\tformat,\n\t\tcontainer,\n\t\tstore,\n\t\tshapeUtilsWithDefaults,\n\t\tbindingUtilsWithDefaults,\n\t\tpageId,\n\t\tbounds,\n\t\tscale,\n\t\tbackground,\n\t\tpadding,\n\t\tdarkMode,\n\t\tpreserveAspectRatio,\n\t\tpreloadingComplete,\n\t\tpreloadingError,\n\t\tlicenseKey,\n\t\tpixelRatio,\n\t])\n\n\tif (preloadingError) {\n\t\treturn <ErrorScreen>Could not load assets.</ErrorScreen>\n\t}\n\n\tif (!preloadingComplete) {\n\t\treturn (\n\t\t\t<LoadingScreen>\n\t\t\t\t<DefaultSpinner />\n\t\t\t</LoadingScreen>\n\t\t)\n\t}\n\n\treturn (\n\t\t<div ref={setContainer} style={{ position: 'relative', width: '100%', height: '100%' }}>\n\t\t\t{url && (\n\t\t\t\t<img\n\t\t\t\t\tsrc={url}\n\t\t\t\t\treferrerPolicy=\"strict-origin-when-cross-origin\"\n\t\t\t\t\tstyle={{ width: '100%', height: '100%' }}\n\t\t\t\t/>\n\t\t\t)}\n\t\t</div>\n\t)\n})\n"],
-  "mappings": "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",
+  "sourcesContent": ["import {\n\tDefaultSpinner,\n\tEditor,\n\tErrorScreen,\n\tLoadingScreen,\n\tTLAnyBindingUtilConstructor,\n\tTLAnyShapeUtilConstructor,\n\tTLAssetStore,\n\tTLEditorSnapshot,\n\tTLImageExportOptions,\n\tTLPageId,\n\tTLStoreSnapshot,\n\tuseShallowArrayIdentity,\n\tuseTLStore,\n} from '@tldraw/editor'\nimport { memo, useLayoutEffect, useMemo, useState } from 'react'\nimport { defaultBindingUtils } from './defaultBindingUtils'\nimport { defaultShapeUtils } from './defaultShapeUtils'\nimport { TLUiAssetUrlOverrides } from './ui/assetUrls'\nimport { usePreloadAssets } from './ui/hooks/usePreloadAssets'\nimport { getSvgAsImage } from './utils/export/export'\nimport { useDefaultEditorAssetsWithOverrides } from './utils/static-assets/assetUrls'\n\n/** @public */\nexport interface TldrawImageProps extends TLImageExportOptions {\n\t/**\n\t * The snapshot to display.\n\t */\n\tsnapshot: Partial<TLEditorSnapshot> | TLStoreSnapshot\n\n\t/**\n\t * The image format to use. Defaults to 'svg'.\n\t */\n\tformat?: 'svg' | 'png'\n\n\t/**\n\t * The page to display. Defaults to the first page.\n\t */\n\tpageId?: TLPageId\n\n\t/**\n\t * Additional shape utils to use.\n\t */\n\tshapeUtils?: readonly TLAnyShapeUtilConstructor[]\n\t/**\n\t * Additional binding utils to use.\n\t */\n\tbindingUtils?: readonly TLAnyBindingUtilConstructor[]\n\t/**\n\t * The license key.\n\t */\n\tlicenseKey?: string\n\t/**\n\t * How should this store resolve assets?\n\t */\n\tassets?: TLAssetStore\n\t/**\n\t * Asset URL overrides.\n\t */\n\tassetUrls?: TLUiAssetUrlOverrides\n}\n\n/**\n * A renderered SVG image of a Tldraw snapshot.\n *\n * @example\n * ```tsx\n * <TldrawImage\n * \tsnapshot={snapshot}\n * \tpageId={pageId}\n * \tbackground={false}\n *  darkMode={true}\n *  bounds={new Box(0,0,600,400)}\n *  scale={1}\n * />\n * ```\n *\n * @public\n * @react\n */\nexport const TldrawImage = memo(function TldrawImage(props: TldrawImageProps) {\n\tconst [url, setUrl] = useState<string | null>(null)\n\tconst [container, setContainer] = useState<HTMLDivElement | null>(null)\n\n\tconst shapeUtils = useShallowArrayIdentity(props.shapeUtils ?? [])\n\tconst shapeUtilsWithDefaults = useMemo(() => [...defaultShapeUtils, ...shapeUtils], [shapeUtils])\n\tconst bindingUtils = useShallowArrayIdentity(props.bindingUtils ?? [])\n\tconst bindingUtilsWithDefaults = useMemo(\n\t\t() => [...defaultBindingUtils, ...bindingUtils],\n\t\t[bindingUtils]\n\t)\n\tconst store = useTLStore({\n\t\tassets: props.assets,\n\t\tsnapshot: props.snapshot,\n\t\tshapeUtils: shapeUtilsWithDefaults,\n\t})\n\n\tconst assets = useDefaultEditorAssetsWithOverrides(props.assetUrls)\n\tconst { done: preloadingComplete, error: preloadingError } = usePreloadAssets(assets)\n\n\tconst {\n\t\tpageId,\n\t\tbounds,\n\t\tscale,\n\t\tpixelRatio,\n\t\tbackground,\n\t\tpadding,\n\t\tdarkMode,\n\t\tpreserveAspectRatio,\n\t\tformat = 'svg',\n\t\tlicenseKey,\n\t} = props\n\n\tuseLayoutEffect(() => {\n\t\tif (!container) return\n\t\tif (!store) return\n\t\tif (!preloadingComplete) return\n\n\t\tlet isCancelled = false\n\n\t\tconst tempElm = document.createElement('div')\n\t\tcontainer.appendChild(tempElm)\n\t\tcontainer.classList.add('tl-container', 'tl-theme__light')\n\n\t\tconst editor = new Editor({\n\t\t\tstore,\n\t\t\tshapeUtils: shapeUtilsWithDefaults,\n\t\t\tbindingUtils: bindingUtilsWithDefaults,\n\t\t\ttools: [],\n\t\t\tgetContainer: () => tempElm,\n\t\t\tlicenseKey,\n\t\t})\n\n\t\tif (pageId) editor.setCurrentPage(pageId)\n\n\t\tconst shapeIds = editor.getCurrentPageShapeIds()\n\n\t\tasync function setSvg() {\n\t\t\tconst svgResult = await editor.getSvgString([...shapeIds], {\n\t\t\t\tbounds,\n\t\t\t\tscale,\n\t\t\t\tbackground,\n\t\t\t\tpadding,\n\t\t\t\tdarkMode,\n\t\t\t\tpreserveAspectRatio,\n\t\t\t})\n\n\t\t\tif (svgResult && !isCancelled) {\n\t\t\t\tif (format === 'svg') {\n\t\t\t\t\tif (!isCancelled) {\n\t\t\t\t\t\tconst blob = new Blob([svgResult.svg], { type: 'image/svg+xml' })\n\t\t\t\t\t\tconst url = URL.createObjectURL(blob)\n\t\t\t\t\t\tsetUrl(url)\n\t\t\t\t\t}\n\t\t\t\t} else if (format === 'png') {\n\t\t\t\t\tconst blob = await getSvgAsImage(editor, svgResult.svg, {\n\t\t\t\t\t\ttype: format,\n\t\t\t\t\t\twidth: svgResult.width,\n\t\t\t\t\t\theight: svgResult.height,\n\t\t\t\t\t\tpixelRatio,\n\t\t\t\t\t})\n\t\t\t\t\tif (blob && !isCancelled) {\n\t\t\t\t\t\tconst url = URL.createObjectURL(blob)\n\t\t\t\t\t\tsetUrl(url)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\teditor.dispose()\n\t\t}\n\n\t\tsetSvg()\n\n\t\treturn () => {\n\t\t\tisCancelled = true\n\t\t}\n\t}, [\n\t\tformat,\n\t\tcontainer,\n\t\tstore,\n\t\tshapeUtilsWithDefaults,\n\t\tbindingUtilsWithDefaults,\n\t\tpageId,\n\t\tbounds,\n\t\tscale,\n\t\tbackground,\n\t\tpadding,\n\t\tdarkMode,\n\t\tpreserveAspectRatio,\n\t\tpreloadingComplete,\n\t\tpreloadingError,\n\t\tlicenseKey,\n\t\tpixelRatio,\n\t])\n\n\tif (preloadingError) {\n\t\treturn <ErrorScreen>Could not load assets.</ErrorScreen>\n\t}\n\n\tif (!preloadingComplete) {\n\t\treturn (\n\t\t\t<LoadingScreen>\n\t\t\t\t<DefaultSpinner />\n\t\t\t</LoadingScreen>\n\t\t)\n\t}\n\n\treturn (\n\t\t<div ref={setContainer} style={{ position: 'relative', width: '100%', height: '100%' }}>\n\t\t\t{url && (\n\t\t\t\t<img\n\t\t\t\t\tsrc={url}\n\t\t\t\t\treferrerPolicy=\"strict-origin-when-cross-origin\"\n\t\t\t\t\tstyle={{ width: '100%', height: '100%' }}\n\t\t\t\t/>\n\t\t\t)}\n\t\t</div>\n\t)\n})\n"],
+  "mappings": "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",
   "names": ["TldrawImage", "url"]
 }
diff --git a/node_modules/tldraw/dist-esm/lib/shapes/shared/TextHelpers.mjs b/node_modules/tldraw/dist-esm/lib/shapes/shared/TextHelpers.mjs
index 35bdaa2..a46fec6 100644
--- a/node_modules/tldraw/dist-esm/lib/shapes/shared/TextHelpers.mjs
+++ b/node_modules/tldraw/dist-esm/lib/shapes/shared/TextHelpers.mjs
@@ -37,7 +37,7 @@ class TextHelpers {
     }
     if (initialFocus === document.body) {
       field.blur();
-    } else if (initialFocus instanceof HTMLElement && initialFocus !== field) {
+    } else if (initialFocus?.instanceOf(HTMLElement) && initialFocus !== field) {
       initialFocus.focus();
     }
   }
diff --git a/node_modules/tldraw/dist-esm/lib/shapes/shared/TextHelpers.mjs.map b/node_modules/tldraw/dist-esm/lib/shapes/shared/TextHelpers.mjs.map
index f6256de..e31db8c 100644
--- a/node_modules/tldraw/dist-esm/lib/shapes/shared/TextHelpers.mjs.map
+++ b/node_modules/tldraw/dist-esm/lib/shapes/shared/TextHelpers.mjs.map
@@ -1,7 +1,7 @@
 {
   "version": 3,
   "sources": ["../../../../src/lib/shapes/shared/TextHelpers.ts"],
-  "sourcesContent": ["/*!\n * MIT License\n * Adapted (mostly copied) the work of https://github.com/fregante/text-field-edit\n * Copyright (c) Federico Brigante <opensource@bfred.it> (bfred.it)\n */\n\n// TODO: Most of this file can be moved into a DOM utils library.\n\n/** @internal */\nexport type ReplacerCallback = (substring: string, ...args: unknown[]) => string\n\n/**\t@public */\nexport const INDENT = '  '\n\n/** @internal */\nexport class TextHelpers {\n\tstatic insertTextFirefox(field: HTMLTextAreaElement | HTMLInputElement, text: string): void {\n\t\t// Found on https://www.everythingfrontend.com/blog/insert-text-into-textarea-at-cursor-position.html \uD83C\uDF88\n\t\tfield.setRangeText(\n\t\t\ttext,\n\t\t\tfield.selectionStart || 0,\n\t\t\tfield.selectionEnd || 0,\n\t\t\t'end' // Without this, the cursor is either at the beginning or text remains selected\n\t\t)\n\n\t\tfield.dispatchEvent(\n\t\t\tnew InputEvent('input', {\n\t\t\t\tdata: text,\n\t\t\t\tinputType: 'insertText',\n\t\t\t\tisComposing: false, // TODO: fix @types/jsdom, this shouldn't be required\n\t\t\t})\n\t\t)\n\t}\n\n\t/**\n\t * Inserts text at the cursor\u2019s position, replacing any selection, with **undo** support and by\n\t * firing the input event.\n\t */\n\tstatic insert(field: HTMLTextAreaElement | HTMLInputElement, text: string): void {\n\t\tconst document = field.ownerDocument\n\t\tconst initialFocus = document.activeElement\n\t\tif (initialFocus !== field) {\n\t\t\tfield.focus()\n\t\t}\n\n\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\tif (!document.execCommand('insertText', false, text)) {\n\t\t\tTextHelpers.insertTextFirefox(field, text)\n\t\t}\n\n\t\tif (initialFocus === document.body) {\n\t\t\tfield.blur()\n\t\t} else if (initialFocus instanceof HTMLElement && initialFocus !== field) {\n\t\t\tinitialFocus.focus()\n\t\t}\n\t}\n\n\t/**\n\t * Replaces the entire content, equivalent to field.value = text but with **undo** support and by\n\t * firing the input event.\n\t */\n\tstatic set(field: HTMLTextAreaElement | HTMLInputElement, text: string): void {\n\t\tfield.select()\n\t\tTextHelpers.insert(field, text)\n\t}\n\n\t/** Get the selected text in a field or an empty string if nothing is selected. */\n\tstatic getSelection(field: HTMLTextAreaElement | HTMLInputElement): string {\n\t\tconst { selectionStart, selectionEnd } = field\n\t\treturn field.value.slice(\n\t\t\tselectionStart ? selectionStart : undefined,\n\t\t\tselectionEnd ? selectionEnd : undefined\n\t\t)\n\t}\n\n\t/**\n\t * Adds the wrappingText before and after field\u2019s selection (or cursor). If endWrappingText is\n\t * provided, it will be used instead of wrappingText at on the right.\n\t */\n\tstatic wrapSelection(\n\t\tfield: HTMLTextAreaElement | HTMLInputElement,\n\t\twrap: string,\n\t\twrapEnd?: string\n\t): void {\n\t\tconst { selectionStart, selectionEnd } = field\n\t\tconst selection = TextHelpers.getSelection(field)\n\t\tTextHelpers.insert(field, wrap + selection + (wrapEnd ?? wrap))\n\n\t\t// Restore the selection around the previously-selected text\n\t\tfield.selectionStart = (selectionStart || 0) + wrap.length\n\t\tfield.selectionEnd = (selectionEnd || 0) + wrap.length\n\t}\n\n\t/** Finds and replaces strings and regex in the field\u2019s value. */\n\tstatic replace(\n\t\tfield: HTMLTextAreaElement | HTMLInputElement,\n\t\tsearchValue: string | RegExp,\n\t\treplacer: string | ReplacerCallback\n\t): void {\n\t\t/** Remembers how much each match offset should be adjusted */\n\t\tlet drift = 0\n\t\tfield.value.replace(searchValue, (...args): string => {\n\t\t\t// Select current match to replace it later\n\t\t\tconst matchStart = drift + (args[args.length - 2] as number)\n\t\t\tconst matchLength = args[0].length\n\t\t\tfield.selectionStart = matchStart\n\t\t\tfield.selectionEnd = matchStart + matchLength\n\t\t\tconst replacement = typeof replacer === 'string' ? replacer : replacer(...args)\n\t\t\tTextHelpers.insert(field, replacement)\n\t\t\t// Select replacement. Without this, the cursor would be after the replacement\n\t\t\tfield.selectionStart = matchStart\n\t\t\tdrift += replacement.length - matchLength\n\t\t\treturn replacement\n\t\t})\n\t}\n\n\tstatic findLineEnd(value: string, currentEnd: number): number {\n\t\t// Go to the beginning of the last line\n\t\tconst lastLineStart = value.lastIndexOf('\\n', currentEnd - 1) + 1\n\t\t// There's nothing to unindent after the last cursor, so leave it as is\n\t\tif (value.charAt(lastLineStart) !== '\\t') {\n\t\t\treturn currentEnd\n\t\t}\n\t\treturn lastLineStart + 1 // Include the first character, which will be a tab\n\t}\n\n\tstatic indent(element: HTMLTextAreaElement): void {\n\t\tconst { selectionStart, selectionEnd, value } = element\n\t\tconst selectedContrast = value.slice(selectionStart, selectionEnd)\n\t\t// The first line should be indented, even if it starts with \\n\n\t\t// The last line should only be indented if includes any character after \\n\n\t\tconst lineBreakCount = /\\n/g.exec(selectedContrast)?.length\n\n\t\tif (lineBreakCount && lineBreakCount > 0) {\n\t\t\t// Select full first line to replace everything at once\n\t\t\tconst firstLineStart = value.lastIndexOf('\\n', selectionStart - 1) + 1\n\n\t\t\tconst newSelection = element.value.slice(firstLineStart, selectionEnd - 1)\n\t\t\tconst indentedText = newSelection.replace(\n\t\t\t\t/^|\\n/g, // Match all line starts\n\t\t\t\t`$&${INDENT}`\n\t\t\t)\n\t\t\tconst replacementsCount = indentedText.length - newSelection.length\n\n\t\t\t// Replace newSelection with indentedText\n\t\t\telement.setSelectionRange(firstLineStart, selectionEnd - 1)\n\t\t\tTextHelpers.insert(element, indentedText)\n\n\t\t\t// Restore selection position, including the indentation\n\t\t\telement.setSelectionRange(selectionStart + 1, selectionEnd + replacementsCount)\n\t\t} else {\n\t\t\tTextHelpers.insert(element, INDENT)\n\t\t}\n\t}\n\n\t// The first line should always be unindented\n\t// The last line should only be unindented if the selection includes any characters after \\n\n\tstatic unindent(element: HTMLTextAreaElement): void {\n\t\tconst { selectionStart, selectionEnd, value } = element\n\n\t\t// Select the whole first line because it might contain \\t\n\t\tconst firstLineStart = value.lastIndexOf('\\n', selectionStart - 1) + 1\n\t\tconst minimumSelectionEnd = TextHelpers.findLineEnd(value, selectionEnd)\n\n\t\tconst newSelection = element.value.slice(firstLineStart, minimumSelectionEnd)\n\t\tconst indentedText = newSelection.replace(/(^|\\n)(\\t| {1,2})/g, '$1')\n\t\tconst replacementsCount = newSelection.length - indentedText.length\n\n\t\t// Replace newSelection with indentedText\n\t\telement.setSelectionRange(firstLineStart, minimumSelectionEnd)\n\t\tTextHelpers.insert(element, indentedText)\n\n\t\t// Restore selection position, including the indentation\n\t\tconst firstLineIndentation = /\\t| {1,2}/.exec(value.slice(firstLineStart, selectionStart))\n\n\t\tconst difference = firstLineIndentation ? firstLineIndentation[0].length : 0\n\n\t\tconst newSelectionStart = selectionStart - difference\n\t\telement.setSelectionRange(\n\t\t\tselectionStart - difference,\n\t\t\tMath.max(newSelectionStart, selectionEnd - replacementsCount)\n\t\t)\n\t}\n\n\tstatic indentCE(element: HTMLElement): void {\n\t\tconst selection = window.getSelection()\n\t\tconst value = element.innerText\n\t\tconst selectionStart = getCaretIndex(element) ?? 0\n\t\tconst selectionEnd = getCaretIndex(element) ?? 0\n\t\tconst selectedContrast = value.slice(selectionStart, selectionEnd)\n\t\t// The first line should be indented, even if it starts with \\n\n\t\t// The last line should only be indented if includes any character after \\n\n\t\tconst lineBreakCount = /\\n/g.exec(selectedContrast)?.length\n\n\t\tif (lineBreakCount && lineBreakCount > 0) {\n\t\t\t// Select full first line to replace everything at once\n\t\t\tconst firstLineStart = value.lastIndexOf('\\n', selectionStart - 1) + 1\n\n\t\t\tconst newSelection = value.slice(firstLineStart, selectionEnd - 1)\n\t\t\tconst indentedText = newSelection.replace(\n\t\t\t\t/^|\\n/g, // Match all line starts\n\t\t\t\t`$&${INDENT}`\n\t\t\t)\n\t\t\tconst replacementsCount = indentedText.length - newSelection.length\n\n\t\t\t// Replace newSelection with indentedText\n\n\t\t\tif (selection) {\n\t\t\t\tselection.setBaseAndExtent(\n\t\t\t\t\telement,\n\t\t\t\t\tselectionStart + 1,\n\t\t\t\t\telement,\n\t\t\t\t\tselectionEnd + replacementsCount\n\t\t\t\t)\n\t\t\t\t// element.setSelectionRange(firstLineStart, selectionEnd - 1)\n\t\t\t\t// TextHelpers.insert(element, indentedText)\n\n\t\t\t\t// Restore selection position, including the indentation\n\t\t\t\t// element.setSelectionRange(selectionStart + 1, selectionEnd + replacementsCount)\n\t\t\t}\n\t\t} else {\n\t\t\tconst selection = window.getSelection()\n\t\t\telement.innerText = value.slice(0, selectionStart) + INDENT + value.slice(selectionStart)\n\t\t\tselection?.setBaseAndExtent(element, selectionStart + 1, element, selectionStart + 2)\n\t\t\t// TextHelpers.insert(element, INDENT)\n\t\t}\n\t}\n\n\tstatic unindentCE(element: HTMLElement): void {\n\t\tconst selection = window.getSelection()\n\t\tconst value = element.innerText\n\t\t// const { selectionStart, selectionEnd } = element\n\t\tconst selectionStart = getCaretIndex(element) ?? 0\n\t\tconst selectionEnd = getCaretIndex(element) ?? 0\n\n\t\t// Select the whole first line because it might contain \\t\n\t\tconst firstLineStart = value.lastIndexOf('\\n', selectionStart - 1) + 1\n\t\tconst minimumSelectionEnd = TextHelpers.findLineEnd(value, selectionEnd)\n\n\t\tconst newSelection = value.slice(firstLineStart, minimumSelectionEnd)\n\t\tconst indentedText = newSelection.replace(/(^|\\n)(\\t| {1,2})/g, '$1')\n\t\tconst replacementsCount = newSelection.length - indentedText.length\n\n\t\tif (selection) {\n\t\t\t// Replace newSelection with indentedText\n\t\t\tselection.setBaseAndExtent(element, firstLineStart, element, minimumSelectionEnd)\n\t\t\t// TextHelpers.insert(element, indentedText)\n\n\t\t\t// Restore selection position, including the indentation\n\t\t\tconst firstLineIndentation = /\\t| {1,2}/.exec(value.slice(firstLineStart, selectionStart))\n\n\t\t\tconst difference = firstLineIndentation ? firstLineIndentation[0].length : 0\n\n\t\t\tconst newSelectionStart = selectionStart - difference\n\t\t\tselection.setBaseAndExtent(\n\t\t\t\telement,\n\t\t\t\tselectionStart - difference,\n\t\t\t\telement,\n\t\t\t\tMath.max(newSelectionStart, selectionEnd - replacementsCount)\n\t\t\t)\n\t\t}\n\t}\n\n\tstatic fixNewLines = /\\r?\\n|\\r/g\n\n\tstatic normalizeText(text: string) {\n\t\treturn text.replace(TextHelpers.fixNewLines, '\\n')\n\t}\n\n\tstatic normalizeTextForDom(text: string) {\n\t\treturn text\n\t\t\t.replace(TextHelpers.fixNewLines, '\\n')\n\t\t\t.split('\\n')\n\t\t\t.map((x) => x || ' ')\n\t\t\t.join('\\n')\n\t}\n}\n\nfunction getCaretIndex(element: HTMLElement) {\n\tif (typeof window.getSelection === 'undefined') return\n\tconst selection = window.getSelection()\n\tif (!selection) return\n\tlet position = 0\n\tif (selection.rangeCount !== 0) {\n\t\tconst range = selection.getRangeAt(0)\n\t\tconst preCaretRange = range.cloneRange()\n\t\tpreCaretRange.selectNodeContents(element)\n\t\tpreCaretRange.setEnd(range.endContainer, range.endOffset)\n\t\tposition = preCaretRange.toString().length\n\t}\n\treturn position\n}\n"],
-  "mappings": "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",
+  "sourcesContent": ["/*!\n * MIT License\n * Adapted (mostly copied) the work of https://github.com/fregante/text-field-edit\n * Copyright (c) Federico Brigante <opensource@bfred.it> (bfred.it)\n */\n\n// TODO: Most of this file can be moved into a DOM utils library.\n\n/** @internal */\nexport type ReplacerCallback = (substring: string, ...args: unknown[]) => string\n\n/**\t@public */\nexport const INDENT = '  '\n\n/** @internal */\nexport class TextHelpers {\n\tstatic insertTextFirefox(field: HTMLTextAreaElement | HTMLInputElement, text: string): void {\n\t\t// Found on https://www.everythingfrontend.com/blog/insert-text-into-textarea-at-cursor-position.html \uD83C\uDF88\n\t\tfield.setRangeText(\n\t\t\ttext,\n\t\t\tfield.selectionStart || 0,\n\t\t\tfield.selectionEnd || 0,\n\t\t\t'end' // Without this, the cursor is either at the beginning or text remains selected\n\t\t)\n\n\t\tfield.dispatchEvent(\n\t\t\tnew InputEvent('input', {\n\t\t\t\tdata: text,\n\t\t\t\tinputType: 'insertText',\n\t\t\t\tisComposing: false, // TODO: fix @types/jsdom, this shouldn't be required\n\t\t\t})\n\t\t)\n\t}\n\n\t/**\n\t * Inserts text at the cursor\u2019s position, replacing any selection, with **undo** support and by\n\t * firing the input event.\n\t */\n\tstatic insert(field: HTMLTextAreaElement | HTMLInputElement, text: string): void {\n\t\tconst document = field.ownerDocument\n\t\tconst initialFocus = document.activeElement\n\t\tif (initialFocus !== field) {\n\t\t\tfield.focus()\n\t\t}\n\n\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\tif (!document.execCommand('insertText', false, text)) {\n\t\t\tTextHelpers.insertTextFirefox(field, text)\n\t\t}\n\n\t\tif (initialFocus === document.body) {\n\t\t\tfield.blur()\n\t\t} else if (initialFocus?.instanceOf(HTMLElement) && initialFocus !== field) {\n\t\t\tinitialFocus.focus()\n\t\t}\n\t}\n\n\t/**\n\t * Replaces the entire content, equivalent to field.value = text but with **undo** support and by\n\t * firing the input event.\n\t */\n\tstatic set(field: HTMLTextAreaElement | HTMLInputElement, text: string): void {\n\t\tfield.select()\n\t\tTextHelpers.insert(field, text)\n\t}\n\n\t/** Get the selected text in a field or an empty string if nothing is selected. */\n\tstatic getSelection(field: HTMLTextAreaElement | HTMLInputElement): string {\n\t\tconst { selectionStart, selectionEnd } = field\n\t\treturn field.value.slice(\n\t\t\tselectionStart ? selectionStart : undefined,\n\t\t\tselectionEnd ? selectionEnd : undefined\n\t\t)\n\t}\n\n\t/**\n\t * Adds the wrappingText before and after field\u2019s selection (or cursor). If endWrappingText is\n\t * provided, it will be used instead of wrappingText at on the right.\n\t */\n\tstatic wrapSelection(\n\t\tfield: HTMLTextAreaElement | HTMLInputElement,\n\t\twrap: string,\n\t\twrapEnd?: string\n\t): void {\n\t\tconst { selectionStart, selectionEnd } = field\n\t\tconst selection = TextHelpers.getSelection(field)\n\t\tTextHelpers.insert(field, wrap + selection + (wrapEnd ?? wrap))\n\n\t\t// Restore the selection around the previously-selected text\n\t\tfield.selectionStart = (selectionStart || 0) + wrap.length\n\t\tfield.selectionEnd = (selectionEnd || 0) + wrap.length\n\t}\n\n\t/** Finds and replaces strings and regex in the field\u2019s value. */\n\tstatic replace(\n\t\tfield: HTMLTextAreaElement | HTMLInputElement,\n\t\tsearchValue: string | RegExp,\n\t\treplacer: string | ReplacerCallback\n\t): void {\n\t\t/** Remembers how much each match offset should be adjusted */\n\t\tlet drift = 0\n\t\tfield.value.replace(searchValue, (...args): string => {\n\t\t\t// Select current match to replace it later\n\t\t\tconst matchStart = drift + (args[args.length - 2] as number)\n\t\t\tconst matchLength = args[0].length\n\t\t\tfield.selectionStart = matchStart\n\t\t\tfield.selectionEnd = matchStart + matchLength\n\t\t\tconst replacement = typeof replacer === 'string' ? replacer : replacer(...args)\n\t\t\tTextHelpers.insert(field, replacement)\n\t\t\t// Select replacement. Without this, the cursor would be after the replacement\n\t\t\tfield.selectionStart = matchStart\n\t\t\tdrift += replacement.length - matchLength\n\t\t\treturn replacement\n\t\t})\n\t}\n\n\tstatic findLineEnd(value: string, currentEnd: number): number {\n\t\t// Go to the beginning of the last line\n\t\tconst lastLineStart = value.lastIndexOf('\\n', currentEnd - 1) + 1\n\t\t// There's nothing to unindent after the last cursor, so leave it as is\n\t\tif (value.charAt(lastLineStart) !== '\\t') {\n\t\t\treturn currentEnd\n\t\t}\n\t\treturn lastLineStart + 1 // Include the first character, which will be a tab\n\t}\n\n\tstatic indent(element: HTMLTextAreaElement): void {\n\t\tconst { selectionStart, selectionEnd, value } = element\n\t\tconst selectedContrast = value.slice(selectionStart, selectionEnd)\n\t\t// The first line should be indented, even if it starts with \\n\n\t\t// The last line should only be indented if includes any character after \\n\n\t\tconst lineBreakCount = /\\n/g.exec(selectedContrast)?.length\n\n\t\tif (lineBreakCount && lineBreakCount > 0) {\n\t\t\t// Select full first line to replace everything at once\n\t\t\tconst firstLineStart = value.lastIndexOf('\\n', selectionStart - 1) + 1\n\n\t\t\tconst newSelection = element.value.slice(firstLineStart, selectionEnd - 1)\n\t\t\tconst indentedText = newSelection.replace(\n\t\t\t\t/^|\\n/g, // Match all line starts\n\t\t\t\t`$&${INDENT}`\n\t\t\t)\n\t\t\tconst replacementsCount = indentedText.length - newSelection.length\n\n\t\t\t// Replace newSelection with indentedText\n\t\t\telement.setSelectionRange(firstLineStart, selectionEnd - 1)\n\t\t\tTextHelpers.insert(element, indentedText)\n\n\t\t\t// Restore selection position, including the indentation\n\t\t\telement.setSelectionRange(selectionStart + 1, selectionEnd + replacementsCount)\n\t\t} else {\n\t\t\tTextHelpers.insert(element, INDENT)\n\t\t}\n\t}\n\n\t// The first line should always be unindented\n\t// The last line should only be unindented if the selection includes any characters after \\n\n\tstatic unindent(element: HTMLTextAreaElement): void {\n\t\tconst { selectionStart, selectionEnd, value } = element\n\n\t\t// Select the whole first line because it might contain \\t\n\t\tconst firstLineStart = value.lastIndexOf('\\n', selectionStart - 1) + 1\n\t\tconst minimumSelectionEnd = TextHelpers.findLineEnd(value, selectionEnd)\n\n\t\tconst newSelection = element.value.slice(firstLineStart, minimumSelectionEnd)\n\t\tconst indentedText = newSelection.replace(/(^|\\n)(\\t| {1,2})/g, '$1')\n\t\tconst replacementsCount = newSelection.length - indentedText.length\n\n\t\t// Replace newSelection with indentedText\n\t\telement.setSelectionRange(firstLineStart, minimumSelectionEnd)\n\t\tTextHelpers.insert(element, indentedText)\n\n\t\t// Restore selection position, including the indentation\n\t\tconst firstLineIndentation = /\\t| {1,2}/.exec(value.slice(firstLineStart, selectionStart))\n\n\t\tconst difference = firstLineIndentation ? firstLineIndentation[0].length : 0\n\n\t\tconst newSelectionStart = selectionStart - difference\n\t\telement.setSelectionRange(\n\t\t\tselectionStart - difference,\n\t\t\tMath.max(newSelectionStart, selectionEnd - replacementsCount)\n\t\t)\n\t}\n\n\tstatic indentCE(element: HTMLElement): void {\n\t\tconst selection = window.getSelection()\n\t\tconst value = element.innerText\n\t\tconst selectionStart = getCaretIndex(element) ?? 0\n\t\tconst selectionEnd = getCaretIndex(element) ?? 0\n\t\tconst selectedContrast = value.slice(selectionStart, selectionEnd)\n\t\t// The first line should be indented, even if it starts with \\n\n\t\t// The last line should only be indented if includes any character after \\n\n\t\tconst lineBreakCount = /\\n/g.exec(selectedContrast)?.length\n\n\t\tif (lineBreakCount && lineBreakCount > 0) {\n\t\t\t// Select full first line to replace everything at once\n\t\t\tconst firstLineStart = value.lastIndexOf('\\n', selectionStart - 1) + 1\n\n\t\t\tconst newSelection = value.slice(firstLineStart, selectionEnd - 1)\n\t\t\tconst indentedText = newSelection.replace(\n\t\t\t\t/^|\\n/g, // Match all line starts\n\t\t\t\t`$&${INDENT}`\n\t\t\t)\n\t\t\tconst replacementsCount = indentedText.length - newSelection.length\n\n\t\t\t// Replace newSelection with indentedText\n\n\t\t\tif (selection) {\n\t\t\t\tselection.setBaseAndExtent(\n\t\t\t\t\telement,\n\t\t\t\t\tselectionStart + 1,\n\t\t\t\t\telement,\n\t\t\t\t\tselectionEnd + replacementsCount\n\t\t\t\t)\n\t\t\t\t// element.setSelectionRange(firstLineStart, selectionEnd - 1)\n\t\t\t\t// TextHelpers.insert(element, indentedText)\n\n\t\t\t\t// Restore selection position, including the indentation\n\t\t\t\t// element.setSelectionRange(selectionStart + 1, selectionEnd + replacementsCount)\n\t\t\t}\n\t\t} else {\n\t\t\tconst selection = window.getSelection()\n\t\t\telement.innerText = value.slice(0, selectionStart) + INDENT + value.slice(selectionStart)\n\t\t\tselection?.setBaseAndExtent(element, selectionStart + 1, element, selectionStart + 2)\n\t\t\t// TextHelpers.insert(element, INDENT)\n\t\t}\n\t}\n\n\tstatic unindentCE(element: HTMLElement): void {\n\t\tconst selection = window.getSelection()\n\t\tconst value = element.innerText\n\t\t// const { selectionStart, selectionEnd } = element\n\t\tconst selectionStart = getCaretIndex(element) ?? 0\n\t\tconst selectionEnd = getCaretIndex(element) ?? 0\n\n\t\t// Select the whole first line because it might contain \\t\n\t\tconst firstLineStart = value.lastIndexOf('\\n', selectionStart - 1) + 1\n\t\tconst minimumSelectionEnd = TextHelpers.findLineEnd(value, selectionEnd)\n\n\t\tconst newSelection = value.slice(firstLineStart, minimumSelectionEnd)\n\t\tconst indentedText = newSelection.replace(/(^|\\n)(\\t| {1,2})/g, '$1')\n\t\tconst replacementsCount = newSelection.length - indentedText.length\n\n\t\tif (selection) {\n\t\t\t// Replace newSelection with indentedText\n\t\t\tselection.setBaseAndExtent(element, firstLineStart, element, minimumSelectionEnd)\n\t\t\t// TextHelpers.insert(element, indentedText)\n\n\t\t\t// Restore selection position, including the indentation\n\t\t\tconst firstLineIndentation = /\\t| {1,2}/.exec(value.slice(firstLineStart, selectionStart))\n\n\t\t\tconst difference = firstLineIndentation ? firstLineIndentation[0].length : 0\n\n\t\t\tconst newSelectionStart = selectionStart - difference\n\t\t\tselection.setBaseAndExtent(\n\t\t\t\telement,\n\t\t\t\tselectionStart - difference,\n\t\t\t\telement,\n\t\t\t\tMath.max(newSelectionStart, selectionEnd - replacementsCount)\n\t\t\t)\n\t\t}\n\t}\n\n\tstatic fixNewLines = /\\r?\\n|\\r/g\n\n\tstatic normalizeText(text: string) {\n\t\treturn text.replace(TextHelpers.fixNewLines, '\\n')\n\t}\n\n\tstatic normalizeTextForDom(text: string) {\n\t\treturn text\n\t\t\t.replace(TextHelpers.fixNewLines, '\\n')\n\t\t\t.split('\\n')\n\t\t\t.map((x) => x || ' ')\n\t\t\t.join('\\n')\n\t}\n}\n\nfunction getCaretIndex(element: HTMLElement) {\n\tif (typeof window.getSelection === 'undefined') return\n\tconst selection = window.getSelection()\n\tif (!selection) return\n\tlet position = 0\n\tif (selection.rangeCount !== 0) {\n\t\tconst range = selection.getRangeAt(0)\n\t\tconst preCaretRange = range.cloneRange()\n\t\tpreCaretRange.selectNodeContents(element)\n\t\tpreCaretRange.setEnd(range.endContainer, range.endOffset)\n\t\tposition = preCaretRange.toString().length\n\t}\n\treturn position\n}\n"],
+  "mappings": "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",
   "names": ["selection"]
 }
diff --git a/node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/OverflowingToolbar.mjs b/node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/OverflowingToolbar.mjs
index 9d35b1c..1a992ab 100644
--- a/node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/OverflowingToolbar.mjs
+++ b/node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/OverflowingToolbar.mjs
@@ -88,7 +88,7 @@ function OverflowingToolbar({ children }) {
         preventDefault(event);
         const relevantEls = Array.from(mainToolsRef.current?.children ?? []).filter(
           (el2) => {
-            if (!(el2 instanceof HTMLElement)) return false;
+            if (!el2.instanceOf(HTMLElement)) return false;
             if (el2.tagName.toLowerCase() !== "button") return false;
             return !!(el2.offsetWidth || el2.offsetHeight);
           }
diff --git a/node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/OverflowingToolbar.mjs.map b/node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/OverflowingToolbar.mjs.map
index 283c611..f738cf7 100644
--- a/node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/OverflowingToolbar.mjs.map
+++ b/node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/OverflowingToolbar.mjs.map
@@ -1,7 +1,7 @@
 {
   "version": 3,
   "sources": ["../../../../../src/lib/ui/components/Toolbar/OverflowingToolbar.tsx"],
-  "sourcesContent": ["import { preventDefault, useEditor, useEvent, useUniqueSafeId } from '@tldraw/editor'\nimport classNames from 'classnames'\nimport hotkeys from 'hotkeys-js'\nimport { createContext, useEffect, useLayoutEffect, useMemo, useRef, useState } from 'react'\nimport { PORTRAIT_BREAKPOINT } from '../../constants'\nimport { useBreakpoint } from '../../context/breakpoints'\nimport { areShortcutsDisabled } from '../../hooks/useKeyboardShortcuts'\nimport { TLUiToolItem } from '../../hooks/useTools'\nimport { useTranslation } from '../../hooks/useTranslation/useTranslation'\nimport { TldrawUiButton } from '../primitives/Button/TldrawUiButton'\nimport { TldrawUiButtonIcon } from '../primitives/Button/TldrawUiButtonIcon'\nimport {\n\tTldrawUiDropdownMenuContent,\n\tTldrawUiDropdownMenuRoot,\n\tTldrawUiDropdownMenuTrigger,\n} from '../primitives/TldrawUiDropdownMenu'\nimport { TldrawUiMenuContextProvider } from '../primitives/menus/TldrawUiMenuContext'\n\nexport const IsInOverflowContext = createContext(false)\n\n/** @public */\nexport interface OverflowingToolbarProps {\n\tchildren: React.ReactNode\n}\n\n/** @public @react */\nexport function OverflowingToolbar({ children }: OverflowingToolbarProps) {\n\tconst editor = useEditor()\n\tconst id = useUniqueSafeId()\n\tconst breakpoint = useBreakpoint()\n\tconst msg = useTranslation()\n\n\tconst overflowIndex = Math.min(8, 5 + breakpoint)\n\n\tconst [totalItems, setTotalItems] = useState(0)\n\tconst mainToolsRef = useRef<HTMLDivElement>(null)\n\tconst [lastActiveOverflowItem, setLastActiveOverflowItem] = useState<string | null>(null)\n\n\tconst css = useMemo(() => {\n\t\tconst activeCss = lastActiveOverflowItem ? `:not([data-value=\"${lastActiveOverflowItem}\"])` : ''\n\n\t\treturn `\n\t\t\t#${id}_main > *:nth-child(n + ${overflowIndex + (lastActiveOverflowItem ? 1 : 2)})${activeCss} {\n\t\t\t\tdisplay: none;\n\t\t\t}\n\t\t\t#${id}_more > *:nth-child(-n + ${overflowIndex}) {\n\t\t\t\tdisplay: none;\n\t\t\t}\n        `\n\t}, [lastActiveOverflowItem, id, overflowIndex])\n\n\tconst onDomUpdate = useEvent(() => {\n\t\tif (!mainToolsRef.current) return\n\n\t\tconst children = Array.from(mainToolsRef.current.children)\n\t\tsetTotalItems(children.length)\n\n\t\t// If the last active overflow item is no longer in the overflow, clear it\n\t\tconst lastActiveElementIdx = children.findIndex(\n\t\t\t(el) => el.getAttribute('data-value') === lastActiveOverflowItem\n\t\t)\n\t\tif (lastActiveElementIdx <= overflowIndex) {\n\t\t\tsetLastActiveOverflowItem(null)\n\t\t}\n\n\t\t// But if there's a new active item...\n\t\tconst activeElementIdx = Array.from(mainToolsRef.current.children).findIndex(\n\t\t\t(el) => el.getAttribute('aria-checked') === 'true'\n\t\t)\n\t\tif (activeElementIdx === -1) return\n\n\t\t// ...and it's in the overflow, set it as the last active overflow item\n\t\tif (activeElementIdx >= overflowIndex) {\n\t\t\tsetLastActiveOverflowItem(children[activeElementIdx].getAttribute('data-value'))\n\t\t}\n\t})\n\n\tuseLayoutEffect(() => {\n\t\tonDomUpdate()\n\t})\n\n\tuseLayoutEffect(() => {\n\t\tif (!mainToolsRef.current) return\n\n\t\tconst mutationObserver = new MutationObserver(onDomUpdate)\n\t\tmutationObserver.observe(mainToolsRef.current, {\n\t\t\tchildList: true,\n\t\t\tsubtree: true,\n\t\t\tattributeFilter: ['data-value', 'aria-checked'],\n\t\t})\n\n\t\treturn () => {\n\t\t\tmutationObserver.disconnect()\n\t\t}\n\t}, [onDomUpdate])\n\n\tuseEffect(() => {\n\t\tconst keys = [\n\t\t\t['1', 0],\n\t\t\t['2', 1],\n\t\t\t['3', 2],\n\t\t\t['4', 3],\n\t\t\t['5', 4],\n\t\t\t['6', 5],\n\t\t\t['7', 6],\n\t\t\t['8', 7],\n\t\t\t['9', 8],\n\t\t\t['0', 9],\n\t\t] as const\n\n\t\tfor (const [key, index] of keys) {\n\t\t\thotkeys(key, (event) => {\n\t\t\t\tif (areShortcutsDisabled(editor)) return\n\t\t\t\tpreventDefault(event)\n\n\t\t\t\tconst relevantEls = Array.from(mainToolsRef.current?.children ?? []).filter(\n\t\t\t\t\t(el): el is HTMLElement => {\n\t\t\t\t\t\t// only count html elements...\n\t\t\t\t\t\tif (!(el instanceof HTMLElement)) return false\n\n\t\t\t\t\t\t// ...that are buttons...\n\t\t\t\t\t\tif (el.tagName.toLowerCase() !== 'button') return false\n\n\t\t\t\t\t\t// ...that are actually visible\n\t\t\t\t\t\treturn !!(el.offsetWidth || el.offsetHeight)\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t\tconst el = relevantEls[index]\n\t\t\t\tif (el) el.click()\n\t\t\t})\n\t\t}\n\n\t\treturn () => {\n\t\t\thotkeys.unbind('1,2,3,4,5,6,7,8,9,0')\n\t\t}\n\t}, [editor])\n\n\treturn (\n\t\t<>\n\t\t\t<style>{css}</style>\n\t\t\t<div\n\t\t\t\tclassName={classNames('tlui-toolbar__tools', {\n\t\t\t\t\t'tlui-toolbar__tools__mobile': breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM,\n\t\t\t\t})}\n\t\t\t\trole=\"radiogroup\"\n\t\t\t>\n\t\t\t\t<div id={`${id}_main`} ref={mainToolsRef} className=\"tlui-toolbar__tools__list\">\n\t\t\t\t\t<TldrawUiMenuContextProvider type=\"toolbar\" sourceId=\"toolbar\">\n\t\t\t\t\t\t{children}\n\t\t\t\t\t</TldrawUiMenuContextProvider>\n\t\t\t\t</div>\n\t\t\t\t{/* There is a +1 because if the menu is just one item, it's not necessary. */}\n\t\t\t\t{totalItems > overflowIndex + 1 && (\n\t\t\t\t\t<IsInOverflowContext.Provider value={true}>\n\t\t\t\t\t\t<TldrawUiDropdownMenuRoot id=\"toolbar overflow\" modal={false}>\n\t\t\t\t\t\t\t<TldrawUiDropdownMenuTrigger>\n\t\t\t\t\t\t\t\t<TldrawUiButton\n\t\t\t\t\t\t\t\t\ttitle={msg('tool-panel.more')}\n\t\t\t\t\t\t\t\t\ttype=\"tool\"\n\t\t\t\t\t\t\t\t\tclassName=\"tlui-toolbar__overflow\"\n\t\t\t\t\t\t\t\t\tdata-testid=\"tools.more-button\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<TldrawUiButtonIcon icon=\"chevron-up\" />\n\t\t\t\t\t\t\t\t</TldrawUiButton>\n\t\t\t\t\t\t\t</TldrawUiDropdownMenuTrigger>\n\t\t\t\t\t\t\t<TldrawUiDropdownMenuContent side=\"top\" align=\"center\">\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tclassName=\"tlui-buttons__grid\"\n\t\t\t\t\t\t\t\t\tdata-testid=\"tools.more-content\"\n\t\t\t\t\t\t\t\t\tid={`${id}_more`}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<TldrawUiMenuContextProvider type=\"toolbar-overflow\" sourceId=\"toolbar\">\n\t\t\t\t\t\t\t\t\t\t{children}\n\t\t\t\t\t\t\t\t\t</TldrawUiMenuContextProvider>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</TldrawUiDropdownMenuContent>\n\t\t\t\t\t\t</TldrawUiDropdownMenuRoot>\n\t\t\t\t\t</IsInOverflowContext.Provider>\n\t\t\t\t)}\n\t\t\t</div>\n\t\t</>\n\t)\n}\n\nexport const isActiveTLUiToolItem = (\n\titem: TLUiToolItem,\n\tactiveToolId: string | undefined,\n\tgeoState: string | null | undefined\n) => {\n\treturn item.meta?.geo\n\t\t? activeToolId === 'geo' && geoState === item.meta?.geo\n\t\t: activeToolId === item.id\n}\n"],
-  "mappings": "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",
+  "sourcesContent": ["import { preventDefault, useEditor, useEvent, useUniqueSafeId } from '@tldraw/editor'\nimport classNames from 'classnames'\nimport hotkeys from 'hotkeys-js'\nimport { createContext, useEffect, useLayoutEffect, useMemo, useRef, useState } from 'react'\nimport { PORTRAIT_BREAKPOINT } from '../../constants'\nimport { useBreakpoint } from '../../context/breakpoints'\nimport { areShortcutsDisabled } from '../../hooks/useKeyboardShortcuts'\nimport { TLUiToolItem } from '../../hooks/useTools'\nimport { useTranslation } from '../../hooks/useTranslation/useTranslation'\nimport { TldrawUiButton } from '../primitives/Button/TldrawUiButton'\nimport { TldrawUiButtonIcon } from '../primitives/Button/TldrawUiButtonIcon'\nimport {\n\tTldrawUiDropdownMenuContent,\n\tTldrawUiDropdownMenuRoot,\n\tTldrawUiDropdownMenuTrigger,\n} from '../primitives/TldrawUiDropdownMenu'\nimport { TldrawUiMenuContextProvider } from '../primitives/menus/TldrawUiMenuContext'\n\nexport const IsInOverflowContext = createContext(false)\n\n/** @public */\nexport interface OverflowingToolbarProps {\n\tchildren: React.ReactNode\n}\n\n/** @public @react */\nexport function OverflowingToolbar({ children }: OverflowingToolbarProps) {\n\tconst editor = useEditor()\n\tconst id = useUniqueSafeId()\n\tconst breakpoint = useBreakpoint()\n\tconst msg = useTranslation()\n\n\tconst overflowIndex = Math.min(8, 5 + breakpoint)\n\n\tconst [totalItems, setTotalItems] = useState(0)\n\tconst mainToolsRef = useRef<HTMLDivElement>(null)\n\tconst [lastActiveOverflowItem, setLastActiveOverflowItem] = useState<string | null>(null)\n\n\tconst css = useMemo(() => {\n\t\tconst activeCss = lastActiveOverflowItem ? `:not([data-value=\"${lastActiveOverflowItem}\"])` : ''\n\n\t\treturn `\n\t\t\t#${id}_main > *:nth-child(n + ${overflowIndex + (lastActiveOverflowItem ? 1 : 2)})${activeCss} {\n\t\t\t\tdisplay: none;\n\t\t\t}\n\t\t\t#${id}_more > *:nth-child(-n + ${overflowIndex}) {\n\t\t\t\tdisplay: none;\n\t\t\t}\n        `\n\t}, [lastActiveOverflowItem, id, overflowIndex])\n\n\tconst onDomUpdate = useEvent(() => {\n\t\tif (!mainToolsRef.current) return\n\n\t\tconst children = Array.from(mainToolsRef.current.children)\n\t\tsetTotalItems(children.length)\n\n\t\t// If the last active overflow item is no longer in the overflow, clear it\n\t\tconst lastActiveElementIdx = children.findIndex(\n\t\t\t(el) => el.getAttribute('data-value') === lastActiveOverflowItem\n\t\t)\n\t\tif (lastActiveElementIdx <= overflowIndex) {\n\t\t\tsetLastActiveOverflowItem(null)\n\t\t}\n\n\t\t// But if there's a new active item...\n\t\tconst activeElementIdx = Array.from(mainToolsRef.current.children).findIndex(\n\t\t\t(el) => el.getAttribute('aria-checked') === 'true'\n\t\t)\n\t\tif (activeElementIdx === -1) return\n\n\t\t// ...and it's in the overflow, set it as the last active overflow item\n\t\tif (activeElementIdx >= overflowIndex) {\n\t\t\tsetLastActiveOverflowItem(children[activeElementIdx].getAttribute('data-value'))\n\t\t}\n\t})\n\n\tuseLayoutEffect(() => {\n\t\tonDomUpdate()\n\t})\n\n\tuseLayoutEffect(() => {\n\t\tif (!mainToolsRef.current) return\n\n\t\tconst mutationObserver = new MutationObserver(onDomUpdate)\n\t\tmutationObserver.observe(mainToolsRef.current, {\n\t\t\tchildList: true,\n\t\t\tsubtree: true,\n\t\t\tattributeFilter: ['data-value', 'aria-checked'],\n\t\t})\n\n\t\treturn () => {\n\t\t\tmutationObserver.disconnect()\n\t\t}\n\t}, [onDomUpdate])\n\n\tuseEffect(() => {\n\t\tconst keys = [\n\t\t\t['1', 0],\n\t\t\t['2', 1],\n\t\t\t['3', 2],\n\t\t\t['4', 3],\n\t\t\t['5', 4],\n\t\t\t['6', 5],\n\t\t\t['7', 6],\n\t\t\t['8', 7],\n\t\t\t['9', 8],\n\t\t\t['0', 9],\n\t\t] as const\n\n\t\tfor (const [key, index] of keys) {\n\t\t\thotkeys(key, (event) => {\n\t\t\t\tif (areShortcutsDisabled(editor)) return\n\t\t\t\tpreventDefault(event)\n\n\t\t\t\tconst relevantEls = Array.from(mainToolsRef.current?.children ?? []).filter(\n\t\t\t\t\t(el): el is HTMLElement => {\n\t\t\t\t\t\t// only count html elements...\n\t\t\t\t\t\tif (!el.instanceOf(HTMLElement)) return false\n\n\t\t\t\t\t\t// ...that are buttons...\n\t\t\t\t\t\tif (el.tagName.toLowerCase() !== 'button') return false\n\n\t\t\t\t\t\t// ...that are actually visible\n\t\t\t\t\t\treturn !!(el.offsetWidth || el.offsetHeight)\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t\tconst el = relevantEls[index]\n\t\t\t\tif (el) el.click()\n\t\t\t})\n\t\t}\n\n\t\treturn () => {\n\t\t\thotkeys.unbind('1,2,3,4,5,6,7,8,9,0')\n\t\t}\n\t}, [editor])\n\n\treturn (\n\t\t<>\n\t\t\t<style>{css}</style>\n\t\t\t<div\n\t\t\t\tclassName={classNames('tlui-toolbar__tools', {\n\t\t\t\t\t'tlui-toolbar__tools__mobile': breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM,\n\t\t\t\t})}\n\t\t\t\trole=\"radiogroup\"\n\t\t\t>\n\t\t\t\t<div id={`${id}_main`} ref={mainToolsRef} className=\"tlui-toolbar__tools__list\">\n\t\t\t\t\t<TldrawUiMenuContextProvider type=\"toolbar\" sourceId=\"toolbar\">\n\t\t\t\t\t\t{children}\n\t\t\t\t\t</TldrawUiMenuContextProvider>\n\t\t\t\t</div>\n\t\t\t\t{/* There is a +1 because if the menu is just one item, it's not necessary. */}\n\t\t\t\t{totalItems > overflowIndex + 1 && (\n\t\t\t\t\t<IsInOverflowContext.Provider value={true}>\n\t\t\t\t\t\t<TldrawUiDropdownMenuRoot id=\"toolbar overflow\" modal={false}>\n\t\t\t\t\t\t\t<TldrawUiDropdownMenuTrigger>\n\t\t\t\t\t\t\t\t<TldrawUiButton\n\t\t\t\t\t\t\t\t\ttitle={msg('tool-panel.more')}\n\t\t\t\t\t\t\t\t\ttype=\"tool\"\n\t\t\t\t\t\t\t\t\tclassName=\"tlui-toolbar__overflow\"\n\t\t\t\t\t\t\t\t\tdata-testid=\"tools.more-button\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<TldrawUiButtonIcon icon=\"chevron-up\" />\n\t\t\t\t\t\t\t\t</TldrawUiButton>\n\t\t\t\t\t\t\t</TldrawUiDropdownMenuTrigger>\n\t\t\t\t\t\t\t<TldrawUiDropdownMenuContent side=\"top\" align=\"center\">\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tclassName=\"tlui-buttons__grid\"\n\t\t\t\t\t\t\t\t\tdata-testid=\"tools.more-content\"\n\t\t\t\t\t\t\t\t\tid={`${id}_more`}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<TldrawUiMenuContextProvider type=\"toolbar-overflow\" sourceId=\"toolbar\">\n\t\t\t\t\t\t\t\t\t\t{children}\n\t\t\t\t\t\t\t\t\t</TldrawUiMenuContextProvider>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</TldrawUiDropdownMenuContent>\n\t\t\t\t\t\t</TldrawUiDropdownMenuRoot>\n\t\t\t\t\t</IsInOverflowContext.Provider>\n\t\t\t\t)}\n\t\t\t</div>\n\t\t</>\n\t)\n}\n\nexport const isActiveTLUiToolItem = (\n\titem: TLUiToolItem,\n\tactiveToolId: string | undefined,\n\tgeoState: string | null | undefined\n) => {\n\treturn item.meta?.geo\n\t\t? activeToolId === 'geo' && geoState === item.meta?.geo\n\t\t: activeToolId === item.id\n}\n"],
+  "mappings": "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",
   "names": ["children", "el"]
 }
diff --git a/node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiButtonPicker.mjs b/node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiButtonPicker.mjs
index 396bc6f..aae4797 100644
--- a/node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiButtonPicker.mjs
+++ b/node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiButtonPicker.mjs
@@ -1,6 +1,7 @@
 import { jsx } from "react/jsx-runtime";
 import {
-  DefaultColorStyle
+  DefaultColorStyle,
+  useContainer
 } from "@tldraw/editor";
 import classNames from "classnames";
 import { memo, useMemo, useRef } from "react";
@@ -19,6 +20,7 @@ const TldrawUiButtonPicker = memo(function TldrawUiButtonPicker2(props) {
     onHistoryMark,
     theme
   } = props;
+  const container = useContainer();
   const msg = useTranslation();
   const rPointing = useRef(false);
   const rPointingOriginalActiveElement = useRef(null);
@@ -30,7 +32,7 @@ const TldrawUiButtonPicker = memo(function TldrawUiButtonPicker2(props) {
   } = useMemo(() => {
     const handlePointerUp = () => {
       rPointing.current = false;
-      window.removeEventListener("pointerup", handlePointerUp);
+      container.win.removeEventListener("pointerup", handlePointerUp);
       const origActiveEl = rPointingOriginalActiveElement.current;
       if (origActiveEl && ["TEXTAREA", "INPUT"].includes(origActiveEl.nodeName)) {
         origActiveEl.focus();
@@ -48,8 +50,8 @@ const TldrawUiButtonPicker = memo(function TldrawUiButtonPicker2(props) {
       onHistoryMark?.("point picker item");
       onValueChange(style, id);
       rPointing.current = true;
-      rPointingOriginalActiveElement.current = document.activeElement;
-      window.addEventListener("pointerup", handlePointerUp);
+      rPointingOriginalActiveElement.current = container.ownerDocument.activeElement;
+      container.win.addEventListener("pointerup", handlePointerUp);
     };
     const handleButtonPointerEnter2 = (e) => {
       if (!rPointing.current) return;
@@ -67,7 +69,7 @@ const TldrawUiButtonPicker = memo(function TldrawUiButtonPicker2(props) {
       handleButtonPointerEnter: handleButtonPointerEnter2,
       handleButtonPointerUp: handleButtonPointerUp2
     };
-  }, [value, onHistoryMark, onValueChange, style]);
+  }, [value, onHistoryMark, onValueChange, style, container]);
   return /* @__PURE__ */ jsx("div", { "data-testid": `style.${uiType}`, className: classNames("tlui-buttons__grid"), children: items.map((item) => /* @__PURE__ */ jsx(
     TldrawUiButton,
     {
diff --git a/node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiButtonPicker.mjs.map b/node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiButtonPicker.mjs.map
index f75fba7..00d8e42 100644
--- a/node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiButtonPicker.mjs.map
+++ b/node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiButtonPicker.mjs.map
@@ -1,7 +1,7 @@
 {
   "version": 3,
   "sources": ["../../../../../src/lib/ui/components/primitives/TldrawUiButtonPicker.tsx"],
-  "sourcesContent": ["import {\n\tDefaultColorStyle,\n\tSharedStyle,\n\tStyleProp,\n\tTLDefaultColorStyle,\n\tTLDefaultColorTheme,\n} from '@tldraw/editor'\nimport classNames from 'classnames'\nimport { ReactElement, memo, useMemo, useRef } from 'react'\nimport { StyleValuesForUi } from '../../../styles'\nimport { TLUiTranslationKey } from '../../hooks/useTranslation/TLUiTranslationKey'\nimport { useTranslation } from '../../hooks/useTranslation/useTranslation'\nimport { TldrawUiButton } from './Button/TldrawUiButton'\nimport { TldrawUiButtonIcon } from './Button/TldrawUiButtonIcon'\n\n/** @public */\nexport interface TLUiButtonPickerProps<T extends string> {\n\ttitle: string\n\tuiType: string\n\tstyle: StyleProp<T>\n\tvalue: SharedStyle<T>\n\titems: StyleValuesForUi<T>\n\ttheme: TLDefaultColorTheme\n\tonValueChange(style: StyleProp<T>, value: T): void\n\tonHistoryMark?(id: string): void\n}\n\n/** @public */\nexport const TldrawUiButtonPicker = memo(function TldrawUiButtonPicker<T extends string>(\n\tprops: TLUiButtonPickerProps<T>\n) {\n\tconst {\n\t\tuiType,\n\t\titems,\n\t\ttitle,\n\t\tstyle,\n\t\tvalue,\n\t\t// columns = clamp(items.length, 2, 4),\n\t\tonValueChange,\n\t\tonHistoryMark,\n\t\ttheme,\n\t} = props\n\tconst msg = useTranslation()\n\n\tconst rPointing = useRef(false)\n\tconst rPointingOriginalActiveElement = useRef<HTMLElement | null>(null)\n\n\tconst {\n\t\thandleButtonClick,\n\t\thandleButtonPointerDown,\n\t\thandleButtonPointerEnter,\n\t\thandleButtonPointerUp,\n\t} = useMemo(() => {\n\t\tconst handlePointerUp = () => {\n\t\t\trPointing.current = false\n\t\t\twindow.removeEventListener('pointerup', handlePointerUp)\n\n\t\t\t// This is fun little micro-optimization to make sure that the focus\n\t\t\t// is retained on a text label. That way, you can continue typing\n\t\t\t// after selecting a style.\n\t\t\tconst origActiveEl = rPointingOriginalActiveElement.current\n\t\t\tif (origActiveEl && ['TEXTAREA', 'INPUT'].includes(origActiveEl.nodeName)) {\n\t\t\t\torigActiveEl.focus()\n\t\t\t}\n\t\t\trPointingOriginalActiveElement.current = null\n\t\t}\n\n\t\tconst handleButtonClick = (e: React.PointerEvent<HTMLButtonElement>) => {\n\t\t\tconst { id } = e.currentTarget.dataset\n\t\t\tif (value.type === 'shared' && value.value === id) return\n\n\t\t\tonHistoryMark?.('point picker item')\n\t\t\tonValueChange(style, id as T)\n\t\t}\n\n\t\tconst handleButtonPointerDown = (e: React.PointerEvent<HTMLButtonElement>) => {\n\t\t\tconst { id } = e.currentTarget.dataset\n\n\t\t\tonHistoryMark?.('point picker item')\n\t\t\tonValueChange(style, id as T)\n\n\t\t\trPointing.current = true\n\t\t\trPointingOriginalActiveElement.current = document.activeElement as HTMLElement\n\t\t\twindow.addEventListener('pointerup', handlePointerUp) // see TLD-658\n\t\t}\n\n\t\tconst handleButtonPointerEnter = (e: React.PointerEvent<HTMLButtonElement>) => {\n\t\t\tif (!rPointing.current) return\n\n\t\t\tconst { id } = e.currentTarget.dataset\n\t\t\tonValueChange(style, id as T)\n\t\t}\n\n\t\tconst handleButtonPointerUp = (e: React.PointerEvent<HTMLButtonElement>) => {\n\t\t\tconst { id } = e.currentTarget.dataset\n\t\t\tif (value.type === 'shared' && value.value === id) return\n\n\t\t\tonValueChange(style, id as T)\n\t\t}\n\n\t\treturn {\n\t\t\thandleButtonClick,\n\t\t\thandleButtonPointerDown,\n\t\t\thandleButtonPointerEnter,\n\t\t\thandleButtonPointerUp,\n\t\t}\n\t}, [value, onHistoryMark, onValueChange, style])\n\n\treturn (\n\t\t<div data-testid={`style.${uiType}`} className={classNames('tlui-buttons__grid')}>\n\t\t\t{items.map((item) => (\n\t\t\t\t<TldrawUiButton\n\t\t\t\t\ttype=\"icon\"\n\t\t\t\t\tkey={item.value}\n\t\t\t\t\tdata-id={item.value}\n\t\t\t\t\tdata-testid={`style.${uiType}.${item.value}`}\n\t\t\t\t\taria-label={item.value}\n\t\t\t\t\tdata-state={value.type === 'shared' && value.value === item.value ? 'hinted' : undefined}\n\t\t\t\t\ttitle={title + ' \u2014 ' + msg(`${uiType}-style.${item.value}` as TLUiTranslationKey)}\n\t\t\t\t\tclassName={classNames('tlui-button-grid__button')}\n\t\t\t\t\tstyle={\n\t\t\t\t\t\tstyle === (DefaultColorStyle as StyleProp<unknown>)\n\t\t\t\t\t\t\t? { color: theme[item.value as TLDefaultColorStyle].solid }\n\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t}\n\t\t\t\t\tonPointerEnter={handleButtonPointerEnter}\n\t\t\t\t\tonPointerDown={handleButtonPointerDown}\n\t\t\t\t\tonPointerUp={handleButtonPointerUp}\n\t\t\t\t\tonClick={handleButtonClick}\n\t\t\t\t>\n\t\t\t\t\t<TldrawUiButtonIcon icon={item.icon} />\n\t\t\t\t</TldrawUiButton>\n\t\t\t))}\n\t\t</div>\n\t)\n}) as <T extends string>(props: TLUiButtonPickerProps<T>) => ReactElement\n"],
-  "mappings": "AAkIK;AAlIL;AAAA,EACC;AAAA,OAKM;AACP,OAAO,gBAAgB;AACvB,SAAuB,MAAM,SAAS,cAAc;AAGpD,SAAS,sBAAsB;AAC/B,SAAS,sBAAsB;AAC/B,SAAS,0BAA0B;AAe5B,MAAM,uBAAuB,KAAK,SAASA,sBACjD,OACC;AACD,QAAM;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA,IAEA;AAAA,IACA;AAAA,IACA;AAAA,EACD,IAAI;AACJ,QAAM,MAAM,eAAe;AAE3B,QAAM,YAAY,OAAO,KAAK;AAC9B,QAAM,iCAAiC,OAA2B,IAAI;AAEtE,QAAM;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACD,IAAI,QAAQ,MAAM;AACjB,UAAM,kBAAkB,MAAM;AAC7B,gBAAU,UAAU;AACpB,aAAO,oBAAoB,aAAa,eAAe;AAKvD,YAAM,eAAe,+BAA+B;AACpD,UAAI,gBAAgB,CAAC,YAAY,OAAO,EAAE,SAAS,aAAa,QAAQ,GAAG;AAC1E,qBAAa,MAAM;AAAA,MACpB;AACA,qCAA+B,UAAU;AAAA,IAC1C;AAEA,UAAMC,qBAAoB,CAAC,MAA6C;AACvE,YAAM,EAAE,GAAG,IAAI,EAAE,cAAc;AAC/B,UAAI,MAAM,SAAS,YAAY,MAAM,UAAU,GAAI;AAEnD,sBAAgB,mBAAmB;AACnC,oBAAc,OAAO,EAAO;AAAA,IAC7B;AAEA,UAAMC,2BAA0B,CAAC,MAA6C;AAC7E,YAAM,EAAE,GAAG,IAAI,EAAE,cAAc;AAE/B,sBAAgB,mBAAmB;AACnC,oBAAc,OAAO,EAAO;AAE5B,gBAAU,UAAU;AACpB,qCAA+B,UAAU,SAAS;AAClD,aAAO,iBAAiB,aAAa,eAAe;AAAA,IACrD;AAEA,UAAMC,4BAA2B,CAAC,MAA6C;AAC9E,UAAI,CAAC,UAAU,QAAS;AAExB,YAAM,EAAE,GAAG,IAAI,EAAE,cAAc;AAC/B,oBAAc,OAAO,EAAO;AAAA,IAC7B;AAEA,UAAMC,yBAAwB,CAAC,MAA6C;AAC3E,YAAM,EAAE,GAAG,IAAI,EAAE,cAAc;AAC/B,UAAI,MAAM,SAAS,YAAY,MAAM,UAAU,GAAI;AAEnD,oBAAc,OAAO,EAAO;AAAA,IAC7B;AAEA,WAAO;AAAA,MACN,mBAAAH;AAAA,MACA,yBAAAC;AAAA,MACA,0BAAAC;AAAA,MACA,uBAAAC;AAAA,IACD;AAAA,EACD,GAAG,CAAC,OAAO,eAAe,eAAe,KAAK,CAAC;AAE/C,SACC,oBAAC,SAAI,eAAa,SAAS,MAAM,IAAI,WAAW,WAAW,oBAAoB,GAC7E,gBAAM,IAAI,CAAC,SACX;AAAA,IAAC;AAAA;AAAA,MACA,MAAK;AAAA,MAEL,WAAS,KAAK;AAAA,MACd,eAAa,SAAS,MAAM,IAAI,KAAK,KAAK;AAAA,MAC1C,cAAY,KAAK;AAAA,MACjB,cAAY,MAAM,SAAS,YAAY,MAAM,UAAU,KAAK,QAAQ,WAAW;AAAA,MAC/E,OAAO,QAAQ,aAAQ,IAAI,GAAG,MAAM,UAAU,KAAK,KAAK,EAAwB;AAAA,MAChF,WAAW,WAAW,0BAA0B;AAAA,MAChD,OACC,UAAW,oBACR,EAAE,OAAO,MAAM,KAAK,KAA4B,EAAE,MAAM,IACxD;AAAA,MAEJ,gBAAgB;AAAA,MAChB,eAAe;AAAA,MACf,aAAa;AAAA,MACb,SAAS;AAAA,MAET,8BAAC,sBAAmB,MAAM,KAAK,MAAM;AAAA;AAAA,IAjBhC,KAAK;AAAA,EAkBX,CACA,GACF;AAEF,CAAC;",
+  "sourcesContent": ["import {\n\tDefaultColorStyle,\n\tSharedStyle,\n\tStyleProp,\n\tTLDefaultColorStyle,\n\tTLDefaultColorTheme,\n\tuseContainer,\n} from '@tldraw/editor'\nimport classNames from 'classnames'\nimport { ReactElement, memo, useMemo, useRef } from 'react'\nimport { StyleValuesForUi } from '../../../styles'\nimport { TLUiTranslationKey } from '../../hooks/useTranslation/TLUiTranslationKey'\nimport { useTranslation } from '../../hooks/useTranslation/useTranslation'\nimport { TldrawUiButton } from './Button/TldrawUiButton'\nimport { TldrawUiButtonIcon } from './Button/TldrawUiButtonIcon'\n\n/** @public */\nexport interface TLUiButtonPickerProps<T extends string> {\n\ttitle: string\n\tuiType: string\n\tstyle: StyleProp<T>\n\tvalue: SharedStyle<T>\n\titems: StyleValuesForUi<T>\n\ttheme: TLDefaultColorTheme\n\tonValueChange(style: StyleProp<T>, value: T): void\n\tonHistoryMark?(id: string): void\n}\n\n/** @public */\nexport const TldrawUiButtonPicker = memo(function TldrawUiButtonPicker<T extends string>(\n\tprops: TLUiButtonPickerProps<T>\n) {\n\tconst {\n\t\tuiType,\n\t\titems,\n\t\ttitle,\n\t\tstyle,\n\t\tvalue,\n\t\t// columns = clamp(items.length, 2, 4),\n\t\tonValueChange,\n\t\tonHistoryMark,\n\t\ttheme,\n\t} = props\n\tconst container = useContainer()\n\tconst msg = useTranslation()\n\n\tconst rPointing = useRef(false)\n\tconst rPointingOriginalActiveElement = useRef<HTMLElement | null>(null)\n\n\tconst {\n\t\thandleButtonClick,\n\t\thandleButtonPointerDown,\n\t\thandleButtonPointerEnter,\n\t\thandleButtonPointerUp,\n\t} = useMemo(() => {\n\t\tconst handlePointerUp = () => {\n\t\t\trPointing.current = false\n\t\t\tcontainer.win.removeEventListener('pointerup', handlePointerUp)\n\n\t\t\t// This is fun little micro-optimization to make sure that the focus\n\t\t\t// is retained on a text label. That way, you can continue typing\n\t\t\t// after selecting a style.\n\t\t\tconst origActiveEl = rPointingOriginalActiveElement.current\n\t\t\tif (origActiveEl && ['TEXTAREA', 'INPUT'].includes(origActiveEl.nodeName)) {\n\t\t\t\torigActiveEl.focus()\n\t\t\t}\n\t\t\trPointingOriginalActiveElement.current = null\n\t\t}\n\n\t\tconst handleButtonClick = (e: React.PointerEvent<HTMLButtonElement>) => {\n\t\t\tconst { id } = e.currentTarget.dataset\n\t\t\tif (value.type === 'shared' && value.value === id) return\n\n\t\t\tonHistoryMark?.('point picker item')\n\t\t\tonValueChange(style, id as T)\n\t\t}\n\n\t\tconst handleButtonPointerDown = (e: React.PointerEvent<HTMLButtonElement>) => {\n\t\t\tconst { id } = e.currentTarget.dataset\n\n\t\t\tonHistoryMark?.('point picker item')\n\t\t\tonValueChange(style, id as T)\n\n\t\t\trPointing.current = true\n\t\t\trPointingOriginalActiveElement.current = container.ownerDocument.activeElement as HTMLElement\n\t\t\tcontainer.win.addEventListener('pointerup', handlePointerUp) // see TLD-658\n\t\t}\n\n\t\tconst handleButtonPointerEnter = (e: React.PointerEvent<HTMLButtonElement>) => {\n\t\t\tif (!rPointing.current) return\n\n\t\t\tconst { id } = e.currentTarget.dataset\n\t\t\tonValueChange(style, id as T)\n\t\t}\n\n\t\tconst handleButtonPointerUp = (e: React.PointerEvent<HTMLButtonElement>) => {\n\t\t\tconst { id } = e.currentTarget.dataset\n\t\t\tif (value.type === 'shared' && value.value === id) return\n\n\t\t\tonValueChange(style, id as T)\n\t\t}\n\n\t\treturn {\n\t\t\thandleButtonClick,\n\t\t\thandleButtonPointerDown,\n\t\t\thandleButtonPointerEnter,\n\t\t\thandleButtonPointerUp,\n\t\t}\n\t}, [value, onHistoryMark, onValueChange, style, container])\n\n\treturn (\n\t\t<div data-testid={`style.${uiType}`} className={classNames('tlui-buttons__grid')}>\n\t\t\t{items.map((item) => (\n\t\t\t\t<TldrawUiButton\n\t\t\t\t\ttype=\"icon\"\n\t\t\t\t\tkey={item.value}\n\t\t\t\t\tdata-id={item.value}\n\t\t\t\t\tdata-testid={`style.${uiType}.${item.value}`}\n\t\t\t\t\taria-label={item.value}\n\t\t\t\t\tdata-state={value.type === 'shared' && value.value === item.value ? 'hinted' : undefined}\n\t\t\t\t\ttitle={title + ' \u2014 ' + msg(`${uiType}-style.${item.value}` as TLUiTranslationKey)}\n\t\t\t\t\tclassName={classNames('tlui-button-grid__button')}\n\t\t\t\t\tstyle={\n\t\t\t\t\t\tstyle === (DefaultColorStyle as StyleProp<unknown>)\n\t\t\t\t\t\t\t? { color: theme[item.value as TLDefaultColorStyle].solid }\n\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t}\n\t\t\t\t\tonPointerEnter={handleButtonPointerEnter}\n\t\t\t\t\tonPointerDown={handleButtonPointerDown}\n\t\t\t\t\tonPointerUp={handleButtonPointerUp}\n\t\t\t\t\tonClick={handleButtonClick}\n\t\t\t\t>\n\t\t\t\t\t<TldrawUiButtonIcon icon={item.icon} />\n\t\t\t\t</TldrawUiButton>\n\t\t\t))}\n\t\t</div>\n\t)\n}) as <T extends string>(props: TLUiButtonPickerProps<T>) => ReactElement\n"],
+  "mappings": "AAoIK;AApIL;AAAA,EACC;AAAA,EAKA;AAAA,OACM;AACP,OAAO,gBAAgB;AACvB,SAAuB,MAAM,SAAS,cAAc;AAGpD,SAAS,sBAAsB;AAC/B,SAAS,sBAAsB;AAC/B,SAAS,0BAA0B;AAe5B,MAAM,uBAAuB,KAAK,SAASA,sBACjD,OACC;AACD,QAAM;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA,IAEA;AAAA,IACA;AAAA,IACA;AAAA,EACD,IAAI;AACJ,QAAM,YAAY,aAAa;AAC/B,QAAM,MAAM,eAAe;AAE3B,QAAM,YAAY,OAAO,KAAK;AAC9B,QAAM,iCAAiC,OAA2B,IAAI;AAEtE,QAAM;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACD,IAAI,QAAQ,MAAM;AACjB,UAAM,kBAAkB,MAAM;AAC7B,gBAAU,UAAU;AACpB,gBAAU,IAAI,oBAAoB,aAAa,eAAe;AAK9D,YAAM,eAAe,+BAA+B;AACpD,UAAI,gBAAgB,CAAC,YAAY,OAAO,EAAE,SAAS,aAAa,QAAQ,GAAG;AAC1E,qBAAa,MAAM;AAAA,MACpB;AACA,qCAA+B,UAAU;AAAA,IAC1C;AAEA,UAAMC,qBAAoB,CAAC,MAA6C;AACvE,YAAM,EAAE,GAAG,IAAI,EAAE,cAAc;AAC/B,UAAI,MAAM,SAAS,YAAY,MAAM,UAAU,GAAI;AAEnD,sBAAgB,mBAAmB;AACnC,oBAAc,OAAO,EAAO;AAAA,IAC7B;AAEA,UAAMC,2BAA0B,CAAC,MAA6C;AAC7E,YAAM,EAAE,GAAG,IAAI,EAAE,cAAc;AAE/B,sBAAgB,mBAAmB;AACnC,oBAAc,OAAO,EAAO;AAE5B,gBAAU,UAAU;AACpB,qCAA+B,UAAU,UAAU,cAAc;AACjE,gBAAU,IAAI,iBAAiB,aAAa,eAAe;AAAA,IAC5D;AAEA,UAAMC,4BAA2B,CAAC,MAA6C;AAC9E,UAAI,CAAC,UAAU,QAAS;AAExB,YAAM,EAAE,GAAG,IAAI,EAAE,cAAc;AAC/B,oBAAc,OAAO,EAAO;AAAA,IAC7B;AAEA,UAAMC,yBAAwB,CAAC,MAA6C;AAC3E,YAAM,EAAE,GAAG,IAAI,EAAE,cAAc;AAC/B,UAAI,MAAM,SAAS,YAAY,MAAM,UAAU,GAAI;AAEnD,oBAAc,OAAO,EAAO;AAAA,IAC7B;AAEA,WAAO;AAAA,MACN,mBAAAH;AAAA,MACA,yBAAAC;AAAA,MACA,0BAAAC;AAAA,MACA,uBAAAC;AAAA,IACD;AAAA,EACD,GAAG,CAAC,OAAO,eAAe,eAAe,OAAO,SAAS,CAAC;AAE1D,SACC,oBAAC,SAAI,eAAa,SAAS,MAAM,IAAI,WAAW,WAAW,oBAAoB,GAC7E,gBAAM,IAAI,CAAC,SACX;AAAA,IAAC;AAAA;AAAA,MACA,MAAK;AAAA,MAEL,WAAS,KAAK;AAAA,MACd,eAAa,SAAS,MAAM,IAAI,KAAK,KAAK;AAAA,MAC1C,cAAY,KAAK;AAAA,MACjB,cAAY,MAAM,SAAS,YAAY,MAAM,UAAU,KAAK,QAAQ,WAAW;AAAA,MAC/E,OAAO,QAAQ,aAAQ,IAAI,GAAG,MAAM,UAAU,KAAK,KAAK,EAAwB;AAAA,MAChF,WAAW,WAAW,0BAA0B;AAAA,MAChD,OACC,UAAW,oBACR,EAAE,OAAO,MAAM,KAAK,KAA4B,EAAE,MAAM,IACxD;AAAA,MAEJ,gBAAgB;AAAA,MAChB,eAAe;AAAA,MACf,aAAa;AAAA,MACb,SAAS;AAAA,MAET,8BAAC,sBAAmB,MAAM,KAAK,MAAM;AAAA;AAAA,IAjBhC,KAAK;AAAA,EAkBX,CACA,GACF;AAEF,CAAC;",
   "names": ["TldrawUiButtonPicker", "handleButtonClick", "handleButtonPointerDown", "handleButtonPointerEnter", "handleButtonPointerUp"]
 }
diff --git a/node_modules/tldraw/dist-esm/lib/ui/hooks/useClipboardEvents.mjs b/node_modules/tldraw/dist-esm/lib/ui/hooks/useClipboardEvents.mjs
index f69d7b6..d5d1d09 100644
--- a/node_modules/tldraw/dist-esm/lib/ui/hooks/useClipboardEvents.mjs
+++ b/node_modules/tldraw/dist-esm/lib/ui/hooks/useClipboardEvents.mjs
@@ -5,6 +5,7 @@ import {
   preventDefault,
   stopEventPropagation,
   uniq,
+  useContainer,
   useEditor,
   useValue
 } from "@tldraw/editor";
@@ -375,6 +376,7 @@ function useMenuClipboardEvents() {
   };
 }
 function useNativeClipboardEvents() {
+  const container = useContainer();
   const editor = useEditor();
   const trackEvent = useUiEvents();
   const appIsFocused = useValue("editor.isFocused", () => editor.getInstanceState().isFocused, [
@@ -441,17 +443,17 @@ function useNativeClipboardEvents() {
       preventDefault(e);
       trackEvent("paste", { source: "kbd" });
     };
-    document.addEventListener("copy", copy);
-    document.addEventListener("cut", cut);
-    document.addEventListener("paste", paste);
-    document.addEventListener("pointerup", pointerUpHandler);
+    container.ownerDocument.addEventListener("copy", copy);
+    container.ownerDocument.addEventListener("cut", cut);
+    container.ownerDocument.addEventListener("paste", paste);
+    container.ownerDocument.addEventListener("pointerup", pointerUpHandler);
     return () => {
-      document.removeEventListener("copy", copy);
-      document.removeEventListener("cut", cut);
-      document.removeEventListener("paste", paste);
-      document.removeEventListener("pointerup", pointerUpHandler);
+      container.ownerDocument.removeEventListener("copy", copy);
+      container.ownerDocument.removeEventListener("cut", cut);
+      container.ownerDocument.removeEventListener("paste", paste);
+      container.ownerDocument.removeEventListener("pointerup", pointerUpHandler);
     };
-  }, [editor, trackEvent, appIsFocused]);
+  }, [editor, trackEvent, appIsFocused, container]);
 }
 export {
   isValidHttpURL,
diff --git a/node_modules/tldraw/dist-esm/lib/ui/hooks/useClipboardEvents.mjs.map b/node_modules/tldraw/dist-esm/lib/ui/hooks/useClipboardEvents.mjs.map
index d89a49b..66438ba 100644
--- a/node_modules/tldraw/dist-esm/lib/ui/hooks/useClipboardEvents.mjs.map
+++ b/node_modules/tldraw/dist-esm/lib/ui/hooks/useClipboardEvents.mjs.map
@@ -1,7 +1,7 @@
 {
   "version": 3,
   "sources": ["../../../../src/lib/ui/hooks/useClipboardEvents.ts"],
-  "sourcesContent": ["import {\n\tEditor,\n\tFileHelpers,\n\tTLExternalContentSource,\n\tVec,\n\tVecLike,\n\tcompact,\n\tisDefined,\n\tpreventDefault,\n\tstopEventPropagation,\n\tuniq,\n\tuseEditor,\n\tuseValue,\n} from '@tldraw/editor'\nimport lz from 'lz-string'\nimport { useCallback, useEffect } from 'react'\nimport { TLDRAW_CUSTOM_PNG_MIME_TYPE, getCanonicalClipboardReadType } from '../../utils/clipboard'\nimport { TLUiEventSource, useUiEvents } from '../context/events'\nimport { pasteExcalidrawContent } from './clipboard/pasteExcalidrawContent'\nimport { pasteFiles } from './clipboard/pasteFiles'\nimport { pasteTldrawContent } from './clipboard/pasteTldrawContent'\nimport { pasteUrl } from './clipboard/pasteUrl'\n\n// Expected paste mime types. The earlier in this array they appear, the higher preference we give\n// them. For example, we prefer the `web image/png+tldraw` type to plain `image/png` as it does not\n// strip some of the extra metadata we write into it.\nconst expectedPasteFileMimeTypes = [\n\tTLDRAW_CUSTOM_PNG_MIME_TYPE,\n\t'image/png',\n\t'image/jpeg',\n\t'image/webp',\n\t'image/svg+xml',\n] satisfies string[]\n\n/**\n * Strip HTML tags from a string.\n * @param html - The HTML to strip.\n * @internal\n */\nfunction stripHtml(html: string) {\n\t// See <https://github.com/developit/preact-markup/blob/4788b8d61b4e24f83688710746ee36e7464f7bbc/src/parse-markup.js#L60-L69>\n\tconst doc = document.implementation.createHTMLDocument('')\n\tdoc.documentElement.innerHTML = html.trim()\n\treturn doc.body.textContent || doc.body.innerText || ''\n}\n\n/** @public */\nexport const isValidHttpURL = (url: string) => {\n\ttry {\n\t\tconst u = new URL(url)\n\t\treturn u.protocol === 'http:' || u.protocol === 'https:'\n\t} catch {\n\t\treturn false\n\t}\n}\n\n/** @public */\nconst getValidHttpURLList = (url: string) => {\n\tconst urls = url.split(/[\\n\\s]/)\n\tfor (const url of urls) {\n\t\ttry {\n\t\t\tconst u = new URL(url)\n\t\t\tif (!(u.protocol === 'http:' || u.protocol === 'https:')) {\n\t\t\t\treturn\n\t\t\t}\n\t\t} catch {\n\t\t\treturn\n\t\t}\n\t}\n\treturn uniq(urls)\n}\n\n/** @public */\nconst isSvgText = (text: string) => {\n\treturn /^<svg/.test(text)\n}\n\nconst INPUTS = ['input', 'select', 'textarea']\n\n/**\n * Get whether to disallow clipboard events.\n *\n * @internal\n */\nfunction areShortcutsDisabled(editor: Editor) {\n\tconst { activeElement } = document\n\n\treturn (\n\t\teditor.menus.hasAnyOpenMenus() ||\n\t\t(activeElement &&\n\t\t\t(activeElement.getAttribute('contenteditable') ||\n\t\t\t\tINPUTS.indexOf(activeElement.tagName.toLowerCase()) > -1))\n\t)\n}\n\n/**\n * Handle text pasted into the editor.\n * @param editor - The editor instance.\n * @param data - The text to paste.\n * @param point - The point at which to paste the text.\n * @internal\n */\nconst handleText = (\n\teditor: Editor,\n\tdata: string,\n\tpoint?: VecLike,\n\tsources?: TLExternalContentSource[]\n) => {\n\tconst validUrlList = getValidHttpURLList(data)\n\tif (validUrlList) {\n\t\tfor (const url of validUrlList) {\n\t\t\tpasteUrl(editor, url, point)\n\t\t}\n\t} else if (isValidHttpURL(data)) {\n\t\tpasteUrl(editor, data, point)\n\t} else if (isSvgText(data)) {\n\t\teditor.markHistoryStoppingPoint('paste')\n\t\teditor.putExternalContent({\n\t\t\ttype: 'svg-text',\n\t\t\ttext: data,\n\t\t\tpoint,\n\t\t\tsources,\n\t\t})\n\t} else {\n\t\teditor.markHistoryStoppingPoint('paste')\n\t\teditor.putExternalContent({\n\t\t\ttype: 'text',\n\t\t\ttext: data,\n\t\t\tpoint,\n\t\t\tsources,\n\t\t})\n\t}\n}\n\n/**\n * Something found on the clipboard, either through the event's clipboard data or the browser's clipboard API.\n * @internal\n */\ntype ClipboardThing =\n\t| {\n\t\t\ttype: 'file'\n\t\t\tsource: Promise<File | null>\n\t  }\n\t| {\n\t\t\ttype: 'blob'\n\t\t\tsource: Promise<Blob | null>\n\t  }\n\t| {\n\t\t\ttype: 'url'\n\t\t\tsource: Promise<string>\n\t  }\n\t| {\n\t\t\ttype: 'html'\n\t\t\tsource: Promise<string>\n\t  }\n\t| {\n\t\t\ttype: 'text'\n\t\t\tsource: Promise<string>\n\t  }\n\t| {\n\t\t\ttype: string\n\t\t\tsource: Promise<string>\n\t  }\n\n/**\n * Handle a paste using event clipboard data. This is the \"original\"\n * paste method that uses the clipboard data from the paste event.\n * https://developer.mozilla.org/en-US/docs/Web/API/ClipboardEvent/clipboardData\n *\n * @param editor - The editor\n * @param clipboardData - The clipboard data\n * @param point - The point to paste at\n * @internal\n */\nconst handlePasteFromEventClipboardData = async (\n\teditor: Editor,\n\tclipboardData: DataTransfer,\n\tpoint?: VecLike\n) => {\n\t// Do not paste while in any editing state\n\tif (editor.getEditingShapeId() !== null) return\n\n\tif (!clipboardData) {\n\t\tthrow Error('No clipboard data')\n\t}\n\n\tconst things: ClipboardThing[] = []\n\n\tfor (const item of Object.values(clipboardData.items)) {\n\t\tswitch (item.kind) {\n\t\t\tcase 'file': {\n\t\t\t\t// files are always blobs\n\t\t\t\tthings.push({\n\t\t\t\t\ttype: 'file',\n\t\t\t\t\tsource: new Promise((r) => r(item.getAsFile())) as Promise<File | null>,\n\t\t\t\t})\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'string': {\n\t\t\t\t// strings can be text or html\n\t\t\t\tif (item.type === 'text/html') {\n\t\t\t\t\tthings.push({\n\t\t\t\t\t\ttype: 'html',\n\t\t\t\t\t\tsource: new Promise((r) => item.getAsString(r)) as Promise<string>,\n\t\t\t\t\t})\n\t\t\t\t} else if (item.type === 'text/plain') {\n\t\t\t\t\tthings.push({\n\t\t\t\t\t\ttype: 'text',\n\t\t\t\t\t\tsource: new Promise((r) => item.getAsString(r)) as Promise<string>,\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tthings.push({ type: item.type, source: new Promise((r) => item.getAsString(r)) })\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\thandleClipboardThings(editor, things, point)\n}\n\n/**\n * Handle a paste using items retrieved from the Clipboard API.\n * https://developer.mozilla.org/en-US/docs/Web/API/ClipboardItem\n *\n * @param editor - The editor\n * @param clipboardItems - The clipboard items to handle\n * @param point - The point to paste at\n * @internal\n */\nconst handlePasteFromClipboardApi = async (\n\teditor: Editor,\n\tclipboardItems: ClipboardItem[],\n\tpoint?: VecLike\n) => {\n\t// We need to populate the array of clipboard things\n\t// based on the ClipboardItems from the Clipboard API.\n\t// This is done in a different way than when using\n\t// the clipboard data from the paste event.\n\n\tconst things: ClipboardThing[] = []\n\n\tfor (const item of clipboardItems) {\n\t\tfor (const type of expectedPasteFileMimeTypes) {\n\t\t\tif (item.types.includes(type)) {\n\t\t\t\tconst blobPromise = item\n\t\t\t\t\t.getType(type)\n\t\t\t\t\t.then((blob) => FileHelpers.rewriteMimeType(blob, getCanonicalClipboardReadType(type)))\n\t\t\t\tthings.push({\n\t\t\t\t\ttype: 'blob',\n\t\t\t\t\tsource: blobPromise,\n\t\t\t\t})\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif (item.types.includes('text/html')) {\n\t\t\tthings.push({\n\t\t\t\ttype: 'html',\n\t\t\t\tsource: (async () => {\n\t\t\t\t\tconst blob = await item.getType('text/html')\n\t\t\t\t\treturn await FileHelpers.blobToText(blob)\n\t\t\t\t})(),\n\t\t\t})\n\t\t}\n\n\t\tif (item.types.includes('text/uri-list')) {\n\t\t\tthings.push({\n\t\t\t\ttype: 'url',\n\t\t\t\tsource: (async () => {\n\t\t\t\t\tconst blob = await item.getType('text/uri-list')\n\t\t\t\t\treturn await FileHelpers.blobToText(blob)\n\t\t\t\t})(),\n\t\t\t})\n\t\t}\n\n\t\tif (item.types.includes('text/plain')) {\n\t\t\tthings.push({\n\t\t\t\ttype: 'text',\n\t\t\t\tsource: (async () => {\n\t\t\t\t\tconst blob = await item.getType('text/plain')\n\t\t\t\t\treturn await FileHelpers.blobToText(blob)\n\t\t\t\t})(),\n\t\t\t})\n\t\t}\n\t}\n\n\treturn await handleClipboardThings(editor, things, point)\n}\n\nasync function handleClipboardThings(editor: Editor, things: ClipboardThing[], point?: VecLike) {\n\t// 1. Handle files\n\t//\n\t// We need to handle files separately because if we want them to\n\t// be placed next to each other, we need to create them all at once.\n\n\tconst files = things.filter(\n\t\t(t) => (t.type === 'file' || t.type === 'blob') && t.source !== null\n\t) as Extract<ClipboardThing, { type: 'file' } | { type: 'blob' }>[]\n\n\t// Just paste the files, nothing else\n\tif (files.length) {\n\t\tif (files.length > editor.options.maxFilesAtOnce) {\n\t\t\tthrow Error('Too many files')\n\t\t}\n\t\tconst fileBlobs = compact(await Promise.all(files.map((t) => t.source)))\n\t\treturn await pasteFiles(editor, fileBlobs, point)\n\t}\n\n\t// 2. Generate clipboard results for non-file things\n\t//\n\t// Getting the source from the items is async, however they must be accessed syncronously;\n\t// we can't await them in a loop. So we'll map them to promises and await them all at once,\n\t// then make decisions based on what we find.\n\n\tconst results = await Promise.all<TLExternalContentSource>(\n\t\tthings\n\t\t\t.filter((t) => t.type !== 'file')\n\t\t\t.map(\n\t\t\t\t(t) =>\n\t\t\t\t\tnew Promise((r) => {\n\t\t\t\t\t\tconst thing = t as Exclude<ClipboardThing, { type: 'file' } | { type: 'blob' }>\n\n\t\t\t\t\t\tif (thing.type === 'file') {\n\t\t\t\t\t\t\tr({ type: 'error', data: null, reason: 'unexpected file' })\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthing.source.then((text) => {\n\t\t\t\t\t\t\t// first, see if we can find tldraw content, which is JSON inside of an html comment\n\t\t\t\t\t\t\tconst tldrawHtmlComment = text.match(/<div data-tldraw[^>]*>(.*)<\\/div>/)?.[1]\n\n\t\t\t\t\t\t\tif (tldrawHtmlComment) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t// If we've found tldraw content in the html string, use that as JSON\n\t\t\t\t\t\t\t\t\tconst jsonComment = lz.decompressFromBase64(tldrawHtmlComment)\n\t\t\t\t\t\t\t\t\tif (jsonComment === null) {\n\t\t\t\t\t\t\t\t\t\tr({\n\t\t\t\t\t\t\t\t\t\t\ttype: 'error',\n\t\t\t\t\t\t\t\t\t\t\tdata: jsonComment,\n\t\t\t\t\t\t\t\t\t\t\treason: `found tldraw data comment but could not parse base64`,\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tconst json = JSON.parse(jsonComment)\n\t\t\t\t\t\t\t\t\t\tif (json.type !== 'application/tldraw') {\n\t\t\t\t\t\t\t\t\t\t\tr({\n\t\t\t\t\t\t\t\t\t\t\t\ttype: 'error',\n\t\t\t\t\t\t\t\t\t\t\t\tdata: json,\n\t\t\t\t\t\t\t\t\t\t\t\treason: `found tldraw data comment but JSON was of a different type: ${json.type}`,\n\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (typeof json.data === 'string') {\n\t\t\t\t\t\t\t\t\t\t\tr({\n\t\t\t\t\t\t\t\t\t\t\t\ttype: 'error',\n\t\t\t\t\t\t\t\t\t\t\t\tdata: json,\n\t\t\t\t\t\t\t\t\t\t\t\treason:\n\t\t\t\t\t\t\t\t\t\t\t\t\t'found tldraw json but data was a string instead of a TLClipboardModel object',\n\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tr({ type: 'tldraw', data: json.data })\n\t\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t\t\tr({\n\t\t\t\t\t\t\t\t\t\ttype: 'error',\n\t\t\t\t\t\t\t\t\t\tdata: tldrawHtmlComment,\n\t\t\t\t\t\t\t\t\t\treason:\n\t\t\t\t\t\t\t\t\t\t\t'found tldraw json but data was a string instead of a TLClipboardModel object',\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (thing.type === 'html') {\n\t\t\t\t\t\t\t\t\tr({ type: 'text', data: text, subtype: 'html' })\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (thing.type === 'url') {\n\t\t\t\t\t\t\t\t\tr({ type: 'text', data: text, subtype: 'url' })\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// if we have not found a tldraw comment, Otherwise, try to parse the text as JSON directly.\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tconst json = JSON.parse(text)\n\t\t\t\t\t\t\t\t\tif (json.type === 'excalidraw/clipboard') {\n\t\t\t\t\t\t\t\t\t\t// If the clipboard contains content copied from excalidraw, then paste that\n\t\t\t\t\t\t\t\t\t\tr({ type: 'excalidraw', data: json })\n\t\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tr({ type: 'text', data: text, subtype: 'json' })\n\t\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t\t\t// If we could not parse the text as JSON, then it's just text\n\t\t\t\t\t\t\t\t\tr({ type: 'text', data: text, subtype: 'text' })\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tr({ type: 'error', data: text, reason: 'unhandled case' })\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t)\n\t)\n\n\t// 3.\n\t//\n\t// Now that we know what kind of stuff we're dealing with, we can actual create some content.\n\t// There are priorities here, so order matters: we've already handled images and files, which\n\t// take first priority; then we want to handle tldraw content, then excalidraw content, then\n\t// html content, then links, and finally text content.\n\n\t// Try to paste tldraw content\n\tfor (const result of results) {\n\t\tif (result.type === 'tldraw') {\n\t\t\tpasteTldrawContent(editor, result.data, point)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Try to paste excalidraw content\n\tfor (const result of results) {\n\t\tif (result.type === 'excalidraw') {\n\t\t\tpasteExcalidrawContent(editor, result.data, point)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Try to paste html content\n\tfor (const result of results) {\n\t\tif (result.type === 'text' && result.subtype === 'html') {\n\t\t\t// try to find a link\n\t\t\tconst rootNode = new DOMParser().parseFromString(result.data, 'text/html')\n\t\t\tconst bodyNode = rootNode.querySelector('body')\n\n\t\t\t// Edge on Windows 11 home appears to paste a link as a single <a/> in\n\t\t\t// the HTML document. If we're pasting a single like tag we'll just\n\t\t\t// assume the user meant to paste the URL.\n\t\t\tconst isHtmlSingleLink =\n\t\t\t\tbodyNode &&\n\t\t\t\tArray.from(bodyNode.children).filter((el) => el.nodeType === 1).length === 1 &&\n\t\t\t\tbodyNode.firstElementChild &&\n\t\t\t\tbodyNode.firstElementChild.tagName === 'A' &&\n\t\t\t\tbodyNode.firstElementChild.hasAttribute('href') &&\n\t\t\t\tbodyNode.firstElementChild.getAttribute('href') !== ''\n\n\t\t\tif (isHtmlSingleLink) {\n\t\t\t\tconst href = bodyNode.firstElementChild.getAttribute('href')!\n\t\t\t\thandleText(editor, href, point, results)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// If the html is NOT a link, and we have NO OTHER texty content, then paste the html as text\n\t\t\tif (!results.some((r) => r.type === 'text' && r.subtype !== 'html') && result.data.trim()) {\n\t\t\t\thandleText(editor, stripHtml(result.data), point, results)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\t// Try to paste a link\n\tfor (const result of results) {\n\t\tif (result.type === 'text' && result.subtype === 'url') {\n\t\t\tpasteUrl(editor, result.data, point, results)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Finally, if we haven't bailed on anything yet, we can paste text content\n\tfor (const result of results) {\n\t\tif (result.type === 'text' && result.subtype === 'text' && result.data.trim()) {\n\t\t\t// The clipboard may include multiple text items, but we only want to paste the first one\n\t\t\thandleText(editor, result.data, point, results)\n\t\t\treturn\n\t\t}\n\t}\n}\n\n/**\n * When the user copies, write the contents to local storage and to the clipboard\n *\n * @param editor - The editor instance.\n * @public\n */\nconst handleNativeOrMenuCopy = async (editor: Editor) => {\n\tconst content = await editor.resolveAssetsInContent(\n\t\teditor.getContentFromCurrentPage(editor.getSelectedShapeIds())\n\t)\n\tif (!content) {\n\t\tif (navigator && navigator.clipboard) {\n\t\t\tnavigator.clipboard.writeText('')\n\t\t}\n\t\treturn\n\t}\n\n\tconst stringifiedClipboard = lz.compressToBase64(\n\t\tJSON.stringify({\n\t\t\ttype: 'application/tldraw',\n\t\t\tkind: 'content',\n\t\t\tdata: content,\n\t\t})\n\t)\n\n\tif (typeof navigator === 'undefined') {\n\t\treturn\n\t} else {\n\t\t// Extract the text from the clipboard\n\t\tconst textItems = content.shapes\n\t\t\t.map((shape) => {\n\t\t\t\tconst util = editor.getShapeUtil(shape)\n\t\t\t\treturn util.getText(shape)\n\t\t\t})\n\t\t\t.filter(isDefined)\n\n\t\tif (navigator.clipboard?.write) {\n\t\t\tconst htmlBlob = new Blob([`<div data-tldraw>${stringifiedClipboard}</div>`], {\n\t\t\t\ttype: 'text/html',\n\t\t\t})\n\n\t\t\tlet textContent = textItems.join(' ')\n\n\t\t\t// This is a bug in chrome android where it won't paste content if\n\t\t\t// the text/plain content is \"\" so we need to always add an empty\n\t\t\t// space \uD83E\uDD2C\n\t\t\tif (textContent === '') {\n\t\t\t\ttextContent = ' '\n\t\t\t}\n\n\t\t\tnavigator.clipboard.write([\n\t\t\t\tnew ClipboardItem({\n\t\t\t\t\t'text/html': htmlBlob,\n\t\t\t\t\t// What is this second blob used for?\n\t\t\t\t\t'text/plain': new Blob([textContent], { type: 'text/plain' }),\n\t\t\t\t}),\n\t\t\t])\n\t\t} else if (navigator.clipboard.writeText) {\n\t\t\tnavigator.clipboard.writeText(`<div data-tldraw>${stringifiedClipboard}</div>`)\n\t\t}\n\t}\n}\n\n/** @public */\nexport function useMenuClipboardEvents() {\n\tconst editor = useEditor()\n\tconst trackEvent = useUiEvents()\n\n\tconst copy = useCallback(\n\t\tasync function onCopy(source: TLUiEventSource) {\n\t\t\tif (editor.getSelectedShapeIds().length === 0) return\n\n\t\t\tawait handleNativeOrMenuCopy(editor)\n\t\t\ttrackEvent('copy', { source })\n\t\t},\n\t\t[editor, trackEvent]\n\t)\n\n\tconst cut = useCallback(\n\t\tasync function onCut(source: TLUiEventSource) {\n\t\t\tif (editor.getSelectedShapeIds().length === 0) return\n\n\t\t\tawait handleNativeOrMenuCopy(editor)\n\t\t\teditor.deleteShapes(editor.getSelectedShapeIds())\n\t\t\ttrackEvent('cut', { source })\n\t\t},\n\t\t[editor, trackEvent]\n\t)\n\n\tconst paste = useCallback(\n\t\tasync function onPaste(\n\t\t\tdata: DataTransfer | ClipboardItem[],\n\t\t\tsource: TLUiEventSource,\n\t\t\tpoint?: VecLike\n\t\t) {\n\t\t\t// If we're editing a shape, or we are focusing an editable input, then\n\t\t\t// we would want the user's paste interaction to go to that element or\n\t\t\t// input instead; e.g. when pasting text into a text shape's content\n\t\t\tif (editor.getEditingShapeId() !== null) return\n\n\t\t\tif (Array.isArray(data) && data[0] instanceof ClipboardItem) {\n\t\t\t\thandlePasteFromClipboardApi(editor, data, point)\n\t\t\t\ttrackEvent('paste', { source: 'menu' })\n\t\t\t} else {\n\t\t\t\t// Read it first and then recurse, kind of weird\n\t\t\t\tnavigator.clipboard.read().then((clipboardItems) => {\n\t\t\t\t\tpaste(clipboardItems, source, point)\n\t\t\t\t})\n\t\t\t}\n\t\t},\n\t\t[editor, trackEvent]\n\t)\n\n\treturn {\n\t\tcopy,\n\t\tcut,\n\t\tpaste,\n\t}\n}\n\n/** @public */\nexport function useNativeClipboardEvents() {\n\tconst editor = useEditor()\n\tconst trackEvent = useUiEvents()\n\n\tconst appIsFocused = useValue('editor.isFocused', () => editor.getInstanceState().isFocused, [\n\t\teditor,\n\t])\n\n\tuseEffect(() => {\n\t\tif (!appIsFocused) return\n\t\tconst copy = async (e: ClipboardEvent) => {\n\t\t\tif (\n\t\t\t\teditor.getSelectedShapeIds().length === 0 ||\n\t\t\t\teditor.getEditingShapeId() !== null ||\n\t\t\t\tareShortcutsDisabled(editor)\n\t\t\t) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tpreventDefault(e)\n\t\t\tawait handleNativeOrMenuCopy(editor)\n\t\t\ttrackEvent('copy', { source: 'kbd' })\n\t\t}\n\n\t\tasync function cut(e: ClipboardEvent) {\n\t\t\tif (\n\t\t\t\teditor.getSelectedShapeIds().length === 0 ||\n\t\t\t\teditor.getEditingShapeId() !== null ||\n\t\t\t\tareShortcutsDisabled(editor)\n\t\t\t) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tpreventDefault(e)\n\t\t\tawait handleNativeOrMenuCopy(editor)\n\t\t\teditor.deleteShapes(editor.getSelectedShapeIds())\n\t\t\ttrackEvent('cut', { source: 'kbd' })\n\t\t}\n\n\t\tlet disablingMiddleClickPaste = false\n\t\tconst pointerUpHandler = (e: PointerEvent) => {\n\t\t\tif (e.button === 1) {\n\t\t\t\t// middle mouse button\n\t\t\t\tdisablingMiddleClickPaste = true\n\t\t\t\teditor.timers.requestAnimationFrame(() => {\n\t\t\t\t\tdisablingMiddleClickPaste = false\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tconst paste = (e: ClipboardEvent) => {\n\t\t\tif (disablingMiddleClickPaste) {\n\t\t\t\tstopEventPropagation(e)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// If we're editing a shape, or we are focusing an editable input, then\n\t\t\t// we would want the user's paste interaction to go to that element or\n\t\t\t// input instead; e.g. when pasting text into a text shape's content\n\t\t\tif (editor.getEditingShapeId() !== null || areShortcutsDisabled(editor)) return\n\n\t\t\t// Where should the shapes go?\n\t\t\tlet point: Vec | undefined = undefined\n\t\t\tlet pasteAtCursor = false\n\n\t\t\t// | Shiftkey | Paste at cursor mode | Paste at point? |\n\t\t\t// |    N \t\t|         N            |       N \t\t\t\t |\n\t\t\t// |    Y \t\t|         N            |       Y \t\t\t\t |\n\t\t\t// |    N \t\t|         Y            |       Y \t\t\t\t |\n\t\t\t// |    Y \t\t|         Y            |       N \t\t\t\t |\n\t\t\tif (editor.inputs.shiftKey) pasteAtCursor = true\n\t\t\tif (editor.user.getIsPasteAtCursorMode()) pasteAtCursor = !pasteAtCursor\n\t\t\tif (pasteAtCursor) point = editor.inputs.currentPagePoint\n\n\t\t\tconst pasteFromEvent = () => {\n\t\t\t\tif (e.clipboardData) {\n\t\t\t\t\thandlePasteFromEventClipboardData(editor, e.clipboardData, point)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// First try to use the clipboard API:\n\t\t\tif (navigator.clipboard?.read) {\n\t\t\t\tnavigator.clipboard.read().then(\n\t\t\t\t\t(clipboardItems) => {\n\t\t\t\t\t\tif (Array.isArray(clipboardItems) && clipboardItems[0] instanceof ClipboardItem) {\n\t\t\t\t\t\t\thandlePasteFromClipboardApi(editor, clipboardItems, point)\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t() => {\n\t\t\t\t\t\t// if reading from the clipboard fails, try to use the event clipboard data\n\t\t\t\t\t\tpasteFromEvent()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tpasteFromEvent()\n\t\t\t}\n\n\t\t\tpreventDefault(e)\n\t\t\ttrackEvent('paste', { source: 'kbd' })\n\t\t}\n\n\t\tdocument.addEventListener('copy', copy)\n\t\tdocument.addEventListener('cut', cut)\n\t\tdocument.addEventListener('paste', paste)\n\t\tdocument.addEventListener('pointerup', pointerUpHandler)\n\n\t\treturn () => {\n\t\t\tdocument.removeEventListener('copy', copy)\n\t\t\tdocument.removeEventListener('cut', cut)\n\t\t\tdocument.removeEventListener('paste', paste)\n\t\t\tdocument.removeEventListener('pointerup', pointerUpHandler)\n\t\t}\n\t}, [editor, trackEvent, appIsFocused])\n}\n"],
-  "mappings": "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",
+  "sourcesContent": ["import {\n\tEditor,\n\tFileHelpers,\n\tTLExternalContentSource,\n\tVec,\n\tVecLike,\n\tcompact,\n\tisDefined,\n\tpreventDefault,\n\tstopEventPropagation,\n\tuniq,\n\tuseContainer,\n\tuseEditor,\n\tuseValue,\n} from '@tldraw/editor'\nimport lz from 'lz-string'\nimport { useCallback, useEffect } from 'react'\nimport { TLDRAW_CUSTOM_PNG_MIME_TYPE, getCanonicalClipboardReadType } from '../../utils/clipboard'\nimport { TLUiEventSource, useUiEvents } from '../context/events'\nimport { pasteExcalidrawContent } from './clipboard/pasteExcalidrawContent'\nimport { pasteFiles } from './clipboard/pasteFiles'\nimport { pasteTldrawContent } from './clipboard/pasteTldrawContent'\nimport { pasteUrl } from './clipboard/pasteUrl'\n\n// Expected paste mime types. The earlier in this array they appear, the higher preference we give\n// them. For example, we prefer the `web image/png+tldraw` type to plain `image/png` as it does not\n// strip some of the extra metadata we write into it.\nconst expectedPasteFileMimeTypes = [\n\tTLDRAW_CUSTOM_PNG_MIME_TYPE,\n\t'image/png',\n\t'image/jpeg',\n\t'image/webp',\n\t'image/svg+xml',\n] satisfies string[]\n\n/**\n * Strip HTML tags from a string.\n * @param html - The HTML to strip.\n * @internal\n */\nfunction stripHtml(html: string) {\n\t// See <https://github.com/developit/preact-markup/blob/4788b8d61b4e24f83688710746ee36e7464f7bbc/src/parse-markup.js#L60-L69>\n\tconst doc = document.implementation.createHTMLDocument('')\n\tdoc.documentElement.innerHTML = html.trim()\n\treturn doc.body.textContent || doc.body.innerText || ''\n}\n\n/** @public */\nexport const isValidHttpURL = (url: string) => {\n\ttry {\n\t\tconst u = new URL(url)\n\t\treturn u.protocol === 'http:' || u.protocol === 'https:'\n\t} catch {\n\t\treturn false\n\t}\n}\n\n/** @public */\nconst getValidHttpURLList = (url: string) => {\n\tconst urls = url.split(/[\\n\\s]/)\n\tfor (const url of urls) {\n\t\ttry {\n\t\t\tconst u = new URL(url)\n\t\t\tif (!(u.protocol === 'http:' || u.protocol === 'https:')) {\n\t\t\t\treturn\n\t\t\t}\n\t\t} catch {\n\t\t\treturn\n\t\t}\n\t}\n\treturn uniq(urls)\n}\n\n/** @public */\nconst isSvgText = (text: string) => {\n\treturn /^<svg/.test(text)\n}\n\nconst INPUTS = ['input', 'select', 'textarea']\n\n/**\n * Get whether to disallow clipboard events.\n *\n * @internal\n */\nfunction areShortcutsDisabled(editor: Editor) {\n\tconst { activeElement } = document\n\n\treturn (\n\t\teditor.menus.hasAnyOpenMenus() ||\n\t\t(activeElement &&\n\t\t\t(activeElement.getAttribute('contenteditable') ||\n\t\t\t\tINPUTS.indexOf(activeElement.tagName.toLowerCase()) > -1))\n\t)\n}\n\n/**\n * Handle text pasted into the editor.\n * @param editor - The editor instance.\n * @param data - The text to paste.\n * @param point - The point at which to paste the text.\n * @internal\n */\nconst handleText = (\n\teditor: Editor,\n\tdata: string,\n\tpoint?: VecLike,\n\tsources?: TLExternalContentSource[]\n) => {\n\tconst validUrlList = getValidHttpURLList(data)\n\tif (validUrlList) {\n\t\tfor (const url of validUrlList) {\n\t\t\tpasteUrl(editor, url, point)\n\t\t}\n\t} else if (isValidHttpURL(data)) {\n\t\tpasteUrl(editor, data, point)\n\t} else if (isSvgText(data)) {\n\t\teditor.markHistoryStoppingPoint('paste')\n\t\teditor.putExternalContent({\n\t\t\ttype: 'svg-text',\n\t\t\ttext: data,\n\t\t\tpoint,\n\t\t\tsources,\n\t\t})\n\t} else {\n\t\teditor.markHistoryStoppingPoint('paste')\n\t\teditor.putExternalContent({\n\t\t\ttype: 'text',\n\t\t\ttext: data,\n\t\t\tpoint,\n\t\t\tsources,\n\t\t})\n\t}\n}\n\n/**\n * Something found on the clipboard, either through the event's clipboard data or the browser's clipboard API.\n * @internal\n */\ntype ClipboardThing =\n\t| {\n\t\t\ttype: 'file'\n\t\t\tsource: Promise<File | null>\n\t  }\n\t| {\n\t\t\ttype: 'blob'\n\t\t\tsource: Promise<Blob | null>\n\t  }\n\t| {\n\t\t\ttype: 'url'\n\t\t\tsource: Promise<string>\n\t  }\n\t| {\n\t\t\ttype: 'html'\n\t\t\tsource: Promise<string>\n\t  }\n\t| {\n\t\t\ttype: 'text'\n\t\t\tsource: Promise<string>\n\t  }\n\t| {\n\t\t\ttype: string\n\t\t\tsource: Promise<string>\n\t  }\n\n/**\n * Handle a paste using event clipboard data. This is the \"original\"\n * paste method that uses the clipboard data from the paste event.\n * https://developer.mozilla.org/en-US/docs/Web/API/ClipboardEvent/clipboardData\n *\n * @param editor - The editor\n * @param clipboardData - The clipboard data\n * @param point - The point to paste at\n * @internal\n */\nconst handlePasteFromEventClipboardData = async (\n\teditor: Editor,\n\tclipboardData: DataTransfer,\n\tpoint?: VecLike\n) => {\n\t// Do not paste while in any editing state\n\tif (editor.getEditingShapeId() !== null) return\n\n\tif (!clipboardData) {\n\t\tthrow Error('No clipboard data')\n\t}\n\n\tconst things: ClipboardThing[] = []\n\n\tfor (const item of Object.values(clipboardData.items)) {\n\t\tswitch (item.kind) {\n\t\t\tcase 'file': {\n\t\t\t\t// files are always blobs\n\t\t\t\tthings.push({\n\t\t\t\t\ttype: 'file',\n\t\t\t\t\tsource: new Promise((r) => r(item.getAsFile())) as Promise<File | null>,\n\t\t\t\t})\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'string': {\n\t\t\t\t// strings can be text or html\n\t\t\t\tif (item.type === 'text/html') {\n\t\t\t\t\tthings.push({\n\t\t\t\t\t\ttype: 'html',\n\t\t\t\t\t\tsource: new Promise((r) => item.getAsString(r)) as Promise<string>,\n\t\t\t\t\t})\n\t\t\t\t} else if (item.type === 'text/plain') {\n\t\t\t\t\tthings.push({\n\t\t\t\t\t\ttype: 'text',\n\t\t\t\t\t\tsource: new Promise((r) => item.getAsString(r)) as Promise<string>,\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tthings.push({ type: item.type, source: new Promise((r) => item.getAsString(r)) })\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\thandleClipboardThings(editor, things, point)\n}\n\n/**\n * Handle a paste using items retrieved from the Clipboard API.\n * https://developer.mozilla.org/en-US/docs/Web/API/ClipboardItem\n *\n * @param editor - The editor\n * @param clipboardItems - The clipboard items to handle\n * @param point - The point to paste at\n * @internal\n */\nconst handlePasteFromClipboardApi = async (\n\teditor: Editor,\n\tclipboardItems: ClipboardItem[],\n\tpoint?: VecLike\n) => {\n\t// We need to populate the array of clipboard things\n\t// based on the ClipboardItems from the Clipboard API.\n\t// This is done in a different way than when using\n\t// the clipboard data from the paste event.\n\n\tconst things: ClipboardThing[] = []\n\n\tfor (const item of clipboardItems) {\n\t\tfor (const type of expectedPasteFileMimeTypes) {\n\t\t\tif (item.types.includes(type)) {\n\t\t\t\tconst blobPromise = item\n\t\t\t\t\t.getType(type)\n\t\t\t\t\t.then((blob) => FileHelpers.rewriteMimeType(blob, getCanonicalClipboardReadType(type)))\n\t\t\t\tthings.push({\n\t\t\t\t\ttype: 'blob',\n\t\t\t\t\tsource: blobPromise,\n\t\t\t\t})\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif (item.types.includes('text/html')) {\n\t\t\tthings.push({\n\t\t\t\ttype: 'html',\n\t\t\t\tsource: (async () => {\n\t\t\t\t\tconst blob = await item.getType('text/html')\n\t\t\t\t\treturn await FileHelpers.blobToText(blob)\n\t\t\t\t})(),\n\t\t\t})\n\t\t}\n\n\t\tif (item.types.includes('text/uri-list')) {\n\t\t\tthings.push({\n\t\t\t\ttype: 'url',\n\t\t\t\tsource: (async () => {\n\t\t\t\t\tconst blob = await item.getType('text/uri-list')\n\t\t\t\t\treturn await FileHelpers.blobToText(blob)\n\t\t\t\t})(),\n\t\t\t})\n\t\t}\n\n\t\tif (item.types.includes('text/plain')) {\n\t\t\tthings.push({\n\t\t\t\ttype: 'text',\n\t\t\t\tsource: (async () => {\n\t\t\t\t\tconst blob = await item.getType('text/plain')\n\t\t\t\t\treturn await FileHelpers.blobToText(blob)\n\t\t\t\t})(),\n\t\t\t})\n\t\t}\n\t}\n\n\treturn await handleClipboardThings(editor, things, point)\n}\n\nasync function handleClipboardThings(editor: Editor, things: ClipboardThing[], point?: VecLike) {\n\t// 1. Handle files\n\t//\n\t// We need to handle files separately because if we want them to\n\t// be placed next to each other, we need to create them all at once.\n\n\tconst files = things.filter(\n\t\t(t) => (t.type === 'file' || t.type === 'blob') && t.source !== null\n\t) as Extract<ClipboardThing, { type: 'file' } | { type: 'blob' }>[]\n\n\t// Just paste the files, nothing else\n\tif (files.length) {\n\t\tif (files.length > editor.options.maxFilesAtOnce) {\n\t\t\tthrow Error('Too many files')\n\t\t}\n\t\tconst fileBlobs = compact(await Promise.all(files.map((t) => t.source)))\n\t\treturn await pasteFiles(editor, fileBlobs, point)\n\t}\n\n\t// 2. Generate clipboard results for non-file things\n\t//\n\t// Getting the source from the items is async, however they must be accessed syncronously;\n\t// we can't await them in a loop. So we'll map them to promises and await them all at once,\n\t// then make decisions based on what we find.\n\n\tconst results = await Promise.all<TLExternalContentSource>(\n\t\tthings\n\t\t\t.filter((t) => t.type !== 'file')\n\t\t\t.map(\n\t\t\t\t(t) =>\n\t\t\t\t\tnew Promise((r) => {\n\t\t\t\t\t\tconst thing = t as Exclude<ClipboardThing, { type: 'file' } | { type: 'blob' }>\n\n\t\t\t\t\t\tif (thing.type === 'file') {\n\t\t\t\t\t\t\tr({ type: 'error', data: null, reason: 'unexpected file' })\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthing.source.then((text) => {\n\t\t\t\t\t\t\t// first, see if we can find tldraw content, which is JSON inside of an html comment\n\t\t\t\t\t\t\tconst tldrawHtmlComment = text.match(/<div data-tldraw[^>]*>(.*)<\\/div>/)?.[1]\n\n\t\t\t\t\t\t\tif (tldrawHtmlComment) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t// If we've found tldraw content in the html string, use that as JSON\n\t\t\t\t\t\t\t\t\tconst jsonComment = lz.decompressFromBase64(tldrawHtmlComment)\n\t\t\t\t\t\t\t\t\tif (jsonComment === null) {\n\t\t\t\t\t\t\t\t\t\tr({\n\t\t\t\t\t\t\t\t\t\t\ttype: 'error',\n\t\t\t\t\t\t\t\t\t\t\tdata: jsonComment,\n\t\t\t\t\t\t\t\t\t\t\treason: `found tldraw data comment but could not parse base64`,\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tconst json = JSON.parse(jsonComment)\n\t\t\t\t\t\t\t\t\t\tif (json.type !== 'application/tldraw') {\n\t\t\t\t\t\t\t\t\t\t\tr({\n\t\t\t\t\t\t\t\t\t\t\t\ttype: 'error',\n\t\t\t\t\t\t\t\t\t\t\t\tdata: json,\n\t\t\t\t\t\t\t\t\t\t\t\treason: `found tldraw data comment but JSON was of a different type: ${json.type}`,\n\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (typeof json.data === 'string') {\n\t\t\t\t\t\t\t\t\t\t\tr({\n\t\t\t\t\t\t\t\t\t\t\t\ttype: 'error',\n\t\t\t\t\t\t\t\t\t\t\t\tdata: json,\n\t\t\t\t\t\t\t\t\t\t\t\treason:\n\t\t\t\t\t\t\t\t\t\t\t\t\t'found tldraw json but data was a string instead of a TLClipboardModel object',\n\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tr({ type: 'tldraw', data: json.data })\n\t\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t\t\tr({\n\t\t\t\t\t\t\t\t\t\ttype: 'error',\n\t\t\t\t\t\t\t\t\t\tdata: tldrawHtmlComment,\n\t\t\t\t\t\t\t\t\t\treason:\n\t\t\t\t\t\t\t\t\t\t\t'found tldraw json but data was a string instead of a TLClipboardModel object',\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (thing.type === 'html') {\n\t\t\t\t\t\t\t\t\tr({ type: 'text', data: text, subtype: 'html' })\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (thing.type === 'url') {\n\t\t\t\t\t\t\t\t\tr({ type: 'text', data: text, subtype: 'url' })\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// if we have not found a tldraw comment, Otherwise, try to parse the text as JSON directly.\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tconst json = JSON.parse(text)\n\t\t\t\t\t\t\t\t\tif (json.type === 'excalidraw/clipboard') {\n\t\t\t\t\t\t\t\t\t\t// If the clipboard contains content copied from excalidraw, then paste that\n\t\t\t\t\t\t\t\t\t\tr({ type: 'excalidraw', data: json })\n\t\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tr({ type: 'text', data: text, subtype: 'json' })\n\t\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t\t\t// If we could not parse the text as JSON, then it's just text\n\t\t\t\t\t\t\t\t\tr({ type: 'text', data: text, subtype: 'text' })\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tr({ type: 'error', data: text, reason: 'unhandled case' })\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t)\n\t)\n\n\t// 3.\n\t//\n\t// Now that we know what kind of stuff we're dealing with, we can actual create some content.\n\t// There are priorities here, so order matters: we've already handled images and files, which\n\t// take first priority; then we want to handle tldraw content, then excalidraw content, then\n\t// html content, then links, and finally text content.\n\n\t// Try to paste tldraw content\n\tfor (const result of results) {\n\t\tif (result.type === 'tldraw') {\n\t\t\tpasteTldrawContent(editor, result.data, point)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Try to paste excalidraw content\n\tfor (const result of results) {\n\t\tif (result.type === 'excalidraw') {\n\t\t\tpasteExcalidrawContent(editor, result.data, point)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Try to paste html content\n\tfor (const result of results) {\n\t\tif (result.type === 'text' && result.subtype === 'html') {\n\t\t\t// try to find a link\n\t\t\tconst rootNode = new DOMParser().parseFromString(result.data, 'text/html')\n\t\t\tconst bodyNode = rootNode.querySelector('body')\n\n\t\t\t// Edge on Windows 11 home appears to paste a link as a single <a/> in\n\t\t\t// the HTML document. If we're pasting a single like tag we'll just\n\t\t\t// assume the user meant to paste the URL.\n\t\t\tconst isHtmlSingleLink =\n\t\t\t\tbodyNode &&\n\t\t\t\tArray.from(bodyNode.children).filter((el) => el.nodeType === 1).length === 1 &&\n\t\t\t\tbodyNode.firstElementChild &&\n\t\t\t\tbodyNode.firstElementChild.tagName === 'A' &&\n\t\t\t\tbodyNode.firstElementChild.hasAttribute('href') &&\n\t\t\t\tbodyNode.firstElementChild.getAttribute('href') !== ''\n\n\t\t\tif (isHtmlSingleLink) {\n\t\t\t\tconst href = bodyNode.firstElementChild.getAttribute('href')!\n\t\t\t\thandleText(editor, href, point, results)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// If the html is NOT a link, and we have NO OTHER texty content, then paste the html as text\n\t\t\tif (!results.some((r) => r.type === 'text' && r.subtype !== 'html') && result.data.trim()) {\n\t\t\t\thandleText(editor, stripHtml(result.data), point, results)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\t// Try to paste a link\n\tfor (const result of results) {\n\t\tif (result.type === 'text' && result.subtype === 'url') {\n\t\t\tpasteUrl(editor, result.data, point, results)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Finally, if we haven't bailed on anything yet, we can paste text content\n\tfor (const result of results) {\n\t\tif (result.type === 'text' && result.subtype === 'text' && result.data.trim()) {\n\t\t\t// The clipboard may include multiple text items, but we only want to paste the first one\n\t\t\thandleText(editor, result.data, point, results)\n\t\t\treturn\n\t\t}\n\t}\n}\n\n/**\n * When the user copies, write the contents to local storage and to the clipboard\n *\n * @param editor - The editor instance.\n * @public\n */\nconst handleNativeOrMenuCopy = async (editor: Editor) => {\n\tconst content = await editor.resolveAssetsInContent(\n\t\teditor.getContentFromCurrentPage(editor.getSelectedShapeIds())\n\t)\n\tif (!content) {\n\t\tif (navigator && navigator.clipboard) {\n\t\t\tnavigator.clipboard.writeText('')\n\t\t}\n\t\treturn\n\t}\n\n\tconst stringifiedClipboard = lz.compressToBase64(\n\t\tJSON.stringify({\n\t\t\ttype: 'application/tldraw',\n\t\t\tkind: 'content',\n\t\t\tdata: content,\n\t\t})\n\t)\n\n\tif (typeof navigator === 'undefined') {\n\t\treturn\n\t} else {\n\t\t// Extract the text from the clipboard\n\t\tconst textItems = content.shapes\n\t\t\t.map((shape) => {\n\t\t\t\tconst util = editor.getShapeUtil(shape)\n\t\t\t\treturn util.getText(shape)\n\t\t\t})\n\t\t\t.filter(isDefined)\n\n\t\tif (navigator.clipboard?.write) {\n\t\t\tconst htmlBlob = new Blob([`<div data-tldraw>${stringifiedClipboard}</div>`], {\n\t\t\t\ttype: 'text/html',\n\t\t\t})\n\n\t\t\tlet textContent = textItems.join(' ')\n\n\t\t\t// This is a bug in chrome android where it won't paste content if\n\t\t\t// the text/plain content is \"\" so we need to always add an empty\n\t\t\t// space \uD83E\uDD2C\n\t\t\tif (textContent === '') {\n\t\t\t\ttextContent = ' '\n\t\t\t}\n\n\t\t\tnavigator.clipboard.write([\n\t\t\t\tnew ClipboardItem({\n\t\t\t\t\t'text/html': htmlBlob,\n\t\t\t\t\t// What is this second blob used for?\n\t\t\t\t\t'text/plain': new Blob([textContent], { type: 'text/plain' }),\n\t\t\t\t}),\n\t\t\t])\n\t\t} else if (navigator.clipboard.writeText) {\n\t\t\tnavigator.clipboard.writeText(`<div data-tldraw>${stringifiedClipboard}</div>`)\n\t\t}\n\t}\n}\n\n/** @public */\nexport function useMenuClipboardEvents() {\n\tconst editor = useEditor()\n\tconst trackEvent = useUiEvents()\n\n\tconst copy = useCallback(\n\t\tasync function onCopy(source: TLUiEventSource) {\n\t\t\tif (editor.getSelectedShapeIds().length === 0) return\n\n\t\t\tawait handleNativeOrMenuCopy(editor)\n\t\t\ttrackEvent('copy', { source })\n\t\t},\n\t\t[editor, trackEvent]\n\t)\n\n\tconst cut = useCallback(\n\t\tasync function onCut(source: TLUiEventSource) {\n\t\t\tif (editor.getSelectedShapeIds().length === 0) return\n\n\t\t\tawait handleNativeOrMenuCopy(editor)\n\t\t\teditor.deleteShapes(editor.getSelectedShapeIds())\n\t\t\ttrackEvent('cut', { source })\n\t\t},\n\t\t[editor, trackEvent]\n\t)\n\n\tconst paste = useCallback(\n\t\tasync function onPaste(\n\t\t\tdata: DataTransfer | ClipboardItem[],\n\t\t\tsource: TLUiEventSource,\n\t\t\tpoint?: VecLike\n\t\t) {\n\t\t\t// If we're editing a shape, or we are focusing an editable input, then\n\t\t\t// we would want the user's paste interaction to go to that element or\n\t\t\t// input instead; e.g. when pasting text into a text shape's content\n\t\t\tif (editor.getEditingShapeId() !== null) return\n\n\t\t\tif (Array.isArray(data) && data[0] instanceof ClipboardItem) {\n\t\t\t\thandlePasteFromClipboardApi(editor, data, point)\n\t\t\t\ttrackEvent('paste', { source: 'menu' })\n\t\t\t} else {\n\t\t\t\t// Read it first and then recurse, kind of weird\n\t\t\t\tnavigator.clipboard.read().then((clipboardItems) => {\n\t\t\t\t\tpaste(clipboardItems, source, point)\n\t\t\t\t})\n\t\t\t}\n\t\t},\n\t\t[editor, trackEvent]\n\t)\n\n\treturn {\n\t\tcopy,\n\t\tcut,\n\t\tpaste,\n\t}\n}\n\n/** @public */\nexport function useNativeClipboardEvents() {\n\tconst container = useContainer()\n\tconst editor = useEditor()\n\tconst trackEvent = useUiEvents()\n\n\tconst appIsFocused = useValue('editor.isFocused', () => editor.getInstanceState().isFocused, [\n\t\teditor,\n\t])\n\n\tuseEffect(() => {\n\t\tif (!appIsFocused) return\n\t\tconst copy = async (e: ClipboardEvent) => {\n\t\t\tif (\n\t\t\t\teditor.getSelectedShapeIds().length === 0 ||\n\t\t\t\teditor.getEditingShapeId() !== null ||\n\t\t\t\tareShortcutsDisabled(editor)\n\t\t\t) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tpreventDefault(e)\n\t\t\tawait handleNativeOrMenuCopy(editor)\n\t\t\ttrackEvent('copy', { source: 'kbd' })\n\t\t}\n\n\t\tasync function cut(e: ClipboardEvent) {\n\t\t\tif (\n\t\t\t\teditor.getSelectedShapeIds().length === 0 ||\n\t\t\t\teditor.getEditingShapeId() !== null ||\n\t\t\t\tareShortcutsDisabled(editor)\n\t\t\t) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tpreventDefault(e)\n\t\t\tawait handleNativeOrMenuCopy(editor)\n\t\t\teditor.deleteShapes(editor.getSelectedShapeIds())\n\t\t\ttrackEvent('cut', { source: 'kbd' })\n\t\t}\n\n\t\tlet disablingMiddleClickPaste = false\n\t\tconst pointerUpHandler = (e: PointerEvent) => {\n\t\t\tif (e.button === 1) {\n\t\t\t\t// middle mouse button\n\t\t\t\tdisablingMiddleClickPaste = true\n\t\t\t\teditor.timers.requestAnimationFrame(() => {\n\t\t\t\t\tdisablingMiddleClickPaste = false\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tconst paste = (e: ClipboardEvent) => {\n\t\t\tif (disablingMiddleClickPaste) {\n\t\t\t\tstopEventPropagation(e)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// If we're editing a shape, or we are focusing an editable input, then\n\t\t\t// we would want the user's paste interaction to go to that element or\n\t\t\t// input instead; e.g. when pasting text into a text shape's content\n\t\t\tif (editor.getEditingShapeId() !== null || areShortcutsDisabled(editor)) return\n\n\t\t\t// Where should the shapes go?\n\t\t\tlet point: Vec | undefined = undefined\n\t\t\tlet pasteAtCursor = false\n\n\t\t\t// | Shiftkey | Paste at cursor mode | Paste at point? |\n\t\t\t// |    N \t\t|         N            |       N \t\t\t\t |\n\t\t\t// |    Y \t\t|         N            |       Y \t\t\t\t |\n\t\t\t// |    N \t\t|         Y            |       Y \t\t\t\t |\n\t\t\t// |    Y \t\t|         Y            |       N \t\t\t\t |\n\t\t\tif (editor.inputs.shiftKey) pasteAtCursor = true\n\t\t\tif (editor.user.getIsPasteAtCursorMode()) pasteAtCursor = !pasteAtCursor\n\t\t\tif (pasteAtCursor) point = editor.inputs.currentPagePoint\n\n\t\t\tconst pasteFromEvent = () => {\n\t\t\t\tif (e.clipboardData) {\n\t\t\t\t\thandlePasteFromEventClipboardData(editor, e.clipboardData, point)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// First try to use the clipboard API:\n\t\t\tif (navigator.clipboard?.read) {\n\t\t\t\tnavigator.clipboard.read().then(\n\t\t\t\t\t(clipboardItems) => {\n\t\t\t\t\t\tif (Array.isArray(clipboardItems) && clipboardItems[0] instanceof ClipboardItem) {\n\t\t\t\t\t\t\thandlePasteFromClipboardApi(editor, clipboardItems, point)\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t() => {\n\t\t\t\t\t\t// if reading from the clipboard fails, try to use the event clipboard data\n\t\t\t\t\t\tpasteFromEvent()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tpasteFromEvent()\n\t\t\t}\n\n\t\t\tpreventDefault(e)\n\t\t\ttrackEvent('paste', { source: 'kbd' })\n\t\t}\n\n\t\tcontainer.ownerDocument.addEventListener('copy', copy)\n\t\tcontainer.ownerDocument.addEventListener('cut', cut)\n\t\tcontainer.ownerDocument.addEventListener('paste', paste)\n\t\tcontainer.ownerDocument.addEventListener('pointerup', pointerUpHandler)\n\n\t\treturn () => {\n\t\t\tcontainer.ownerDocument.removeEventListener('copy', copy)\n\t\t\tcontainer.ownerDocument.removeEventListener('cut', cut)\n\t\t\tcontainer.ownerDocument.removeEventListener('paste', paste)\n\t\t\tcontainer.ownerDocument.removeEventListener('pointerup', pointerUpHandler)\n\t\t}\n\t}, [editor, trackEvent, appIsFocused, container])\n}\n"],
+  "mappings": "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",
   "names": ["url"]
 }
diff --git a/node_modules/tldraw/dist-esm/lib/ui/hooks/useKeyboardShortcuts.mjs b/node_modules/tldraw/dist-esm/lib/ui/hooks/useKeyboardShortcuts.mjs
index e4565d1..eed1021 100644
--- a/node_modules/tldraw/dist-esm/lib/ui/hooks/useKeyboardShortcuts.mjs
+++ b/node_modules/tldraw/dist-esm/lib/ui/hooks/useKeyboardShortcuts.mjs
@@ -1,6 +1,7 @@
 import {
   isAccelKey,
   preventDefault,
+  useContainer,
   useEditor,
   useValue
 } from "@tldraw/editor";
@@ -18,6 +19,7 @@ const SKIP_KBDS = [
   "asset"
 ];
 function useKeyboardShortcuts() {
+  const container = useContainer();
   const editor = useEditor();
   const isReadonlyMode = useReadonly();
   const actions = useActions();
@@ -27,13 +29,17 @@ function useKeyboardShortcuts() {
     if (!isFocused) return;
     const disposables = new Array();
     const hot = (keys, callback) => {
-      hotkeys(keys, { element: document.body }, callback);
+      hotkeys(keys, { element: container.ownerDocument.body }, callback);
       disposables.push(() => {
         hotkeys.unbind(keys, callback);
       });
     };
     const hotUp = (keys, callback) => {
-      hotkeys(keys, { element: document.body, keyup: true, keydown: false }, callback);
+      hotkeys(
+        keys,
+        { element: container.ownerDocument.body, keyup: true, keydown: false },
+        callback
+      );
       disposables.push(() => {
         hotkeys.unbind(keys, callback);
       });
@@ -107,7 +113,7 @@ function useKeyboardShortcuts() {
     return () => {
       disposables.forEach((d) => d());
     };
-  }, [actions, tools, isReadonlyMode, editor, isFocused]);
+  }, [actions, tools, isReadonlyMode, editor, container, isFocused]);
 }
 function getHotkeysStringFromKbd(kbd) {
   return getKeys(kbd).map((kbd2) => {
diff --git a/node_modules/tldraw/dist-esm/lib/ui/hooks/useKeyboardShortcuts.mjs.map b/node_modules/tldraw/dist-esm/lib/ui/hooks/useKeyboardShortcuts.mjs.map
index 9d3b64b..4553c6a 100644
--- a/node_modules/tldraw/dist-esm/lib/ui/hooks/useKeyboardShortcuts.mjs.map
+++ b/node_modules/tldraw/dist-esm/lib/ui/hooks/useKeyboardShortcuts.mjs.map
@@ -1,7 +1,7 @@
 {
   "version": 3,
   "sources": ["../../../../src/lib/ui/hooks/useKeyboardShortcuts.ts"],
-  "sourcesContent": ["import {\n\tEditor,\n\tTLPointerEventInfo,\n\tisAccelKey,\n\tpreventDefault,\n\tuseEditor,\n\tuseValue,\n} from '@tldraw/editor'\nimport hotkeys from 'hotkeys-js'\nimport { useEffect } from 'react'\nimport { useActions } from '../context/actions'\nimport { useReadonly } from './useReadonly'\nimport { useTools } from './useTools'\n\nconst SKIP_KBDS = [\n\t// we set these in useNativeClipboardEvents instead\n\t'copy',\n\t'cut',\n\t'paste',\n\t// There's also an upload asset action, so we don't want to set the kbd twice\n\t'asset',\n]\n\n/** @public */\nexport function useKeyboardShortcuts() {\n\tconst editor = useEditor()\n\n\tconst isReadonlyMode = useReadonly()\n\tconst actions = useActions()\n\tconst tools = useTools()\n\tconst isFocused = useValue('is focused', () => editor.getInstanceState().isFocused, [editor])\n\tuseEffect(() => {\n\t\tif (!isFocused) return\n\n\t\tconst disposables = new Array<() => void>()\n\n\t\tconst hot = (keys: string, callback: (event: KeyboardEvent) => void) => {\n\t\t\thotkeys(keys, { element: document.body }, callback)\n\t\t\tdisposables.push(() => {\n\t\t\t\thotkeys.unbind(keys, callback)\n\t\t\t})\n\t\t}\n\n\t\tconst hotUp = (keys: string, callback: (event: KeyboardEvent) => void) => {\n\t\t\thotkeys(keys, { element: document.body, keyup: true, keydown: false }, callback)\n\t\t\tdisposables.push(() => {\n\t\t\t\thotkeys.unbind(keys, callback)\n\t\t\t})\n\t\t}\n\n\t\t// Add hotkeys for actions and tools.\n\t\t// Except those that in SKIP_KBDS!\n\t\tfor (const action of Object.values(actions)) {\n\t\t\tif (!action.kbd) continue\n\t\t\tif (isReadonlyMode && !action.readonlyOk) continue\n\t\t\tif (SKIP_KBDS.includes(action.id)) continue\n\n\t\t\thot(getHotkeysStringFromKbd(action.kbd), (event) => {\n\t\t\t\tif (areShortcutsDisabled(editor)) return\n\t\t\t\tpreventDefault(event)\n\t\t\t\taction.onSelect('kbd')\n\t\t\t})\n\t\t}\n\n\t\tfor (const tool of Object.values(tools)) {\n\t\t\tif (!tool.kbd || (!tool.readonlyOk && editor.getIsReadonly())) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (SKIP_KBDS.includes(tool.id)) continue\n\n\t\t\thot(getHotkeysStringFromKbd(tool.kbd), (event) => {\n\t\t\t\tif (areShortcutsDisabled(editor)) return\n\t\t\t\tpreventDefault(event)\n\t\t\t\ttool.onSelect('kbd')\n\t\t\t})\n\t\t}\n\n\t\thot(',', (e) => {\n\t\t\t// Skip if shortcuts are disabled\n\t\t\tif (areShortcutsDisabled(editor)) return\n\n\t\t\t// Don't press again if already pressed\n\t\t\tif (editor.inputs.keys.has('Comma')) return\n\n\t\t\tpreventDefault(e) // prevent whatever would normally happen\n\t\t\teditor.focus() // Focus if not already focused\n\n\t\t\teditor.inputs.keys.add('Comma')\n\n\t\t\tconst { x, y, z } = editor.inputs.currentPagePoint\n\t\t\tconst screenpoints = editor.pageToScreen({ x, y })\n\n\t\t\tconst info: TLPointerEventInfo = {\n\t\t\t\ttype: 'pointer',\n\t\t\t\tname: 'pointer_down',\n\t\t\t\tpoint: { x: screenpoints.x, y: screenpoints.y, z },\n\t\t\t\tshiftKey: e.shiftKey,\n\t\t\t\taltKey: e.altKey,\n\t\t\t\tctrlKey: e.metaKey || e.ctrlKey,\n\t\t\t\tmetaKey: e.metaKey,\n\t\t\t\taccelKey: isAccelKey(e),\n\t\t\t\tpointerId: 0,\n\t\t\t\tbutton: 0,\n\t\t\t\tisPen: editor.getInstanceState().isPenMode,\n\t\t\t\ttarget: 'canvas',\n\t\t\t}\n\n\t\t\teditor.dispatch(info)\n\t\t})\n\n\t\thotUp(',', (e) => {\n\t\t\tif (areShortcutsDisabled(editor)) return\n\t\t\tif (!editor.inputs.keys.has('Comma')) return\n\n\t\t\teditor.inputs.keys.delete('Comma')\n\n\t\t\tconst { x, y, z } = editor.inputs.currentScreenPoint\n\t\t\tconst info: TLPointerEventInfo = {\n\t\t\t\ttype: 'pointer',\n\t\t\t\tname: 'pointer_up',\n\t\t\t\tpoint: { x, y, z },\n\t\t\t\tshiftKey: e.shiftKey,\n\t\t\t\taltKey: e.altKey,\n\t\t\t\tctrlKey: e.metaKey || e.ctrlKey,\n\t\t\t\tmetaKey: e.metaKey,\n\t\t\t\taccelKey: isAccelKey(e),\n\t\t\t\tpointerId: 0,\n\t\t\t\tbutton: 0,\n\t\t\t\tisPen: editor.getInstanceState().isPenMode,\n\t\t\t\ttarget: 'canvas',\n\t\t\t}\n\n\t\t\teditor.dispatch(info)\n\t\t})\n\n\t\treturn () => {\n\t\t\tdisposables.forEach((d) => d())\n\t\t}\n\t}, [actions, tools, isReadonlyMode, editor, isFocused])\n}\n\n// Shift is !\n// Alt is ?\n// Cmd / control is $\n// so cmd+shift+u would be $!u\n\nfunction getHotkeysStringFromKbd(kbd: string) {\n\treturn getKeys(kbd)\n\t\t.map((kbd) => {\n\t\t\tlet str = ''\n\t\t\tconst chars = kbd.split('')\n\t\t\tif (chars.length === 1) {\n\t\t\t\tstr = chars[0]\n\t\t\t} else {\n\t\t\t\tif (chars[0] === '!') {\n\t\t\t\t\tstr = `shift+${chars[1]}`\n\t\t\t\t} else if (chars[0] === '?') {\n\t\t\t\t\tif (chars.length === 3 && chars[1] === '!') {\n\t\t\t\t\t\tstr = `alt+shift+${chars[2]}`\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr = `alt+${chars[1]}`\n\t\t\t\t\t}\n\t\t\t\t} else if (chars[0] === '$') {\n\t\t\t\t\tif (chars[1] === '!') {\n\t\t\t\t\t\tstr = `cmd+shift+${chars[2]},ctrl+shift+${chars[2]}`\n\t\t\t\t\t} else if (chars[1] === '?') {\n\t\t\t\t\t\tstr = `cmd+\u2325+${chars[2]},ctrl+alt+${chars[2]}`\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr = `cmd+${chars[1]},ctrl+${chars[1]}`\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstr = kbd\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn str\n\t\t})\n\t\t.join(',')\n}\n\n// Logic to split kbd string from hotkeys-js util.\nfunction getKeys(key: string) {\n\tif (typeof key !== 'string') key = ''\n\tkey = key.replace(/\\s/g, '')\n\tconst keys = key.split(',')\n\tlet index = keys.lastIndexOf('')\n\n\tfor (; index >= 0; ) {\n\t\tkeys[index - 1] += ','\n\t\tkeys.splice(index, 1)\n\t\tindex = keys.lastIndexOf('')\n\t}\n\n\treturn keys\n}\n\nexport function areShortcutsDisabled(editor: Editor) {\n\treturn (\n\t\teditor.menus.hasAnyOpenMenus() ||\n\t\teditor.getEditingShapeId() !== null ||\n\t\teditor.getCrashingError()\n\t)\n}\n"],
-  "mappings": "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",
+  "sourcesContent": ["import {\n\tEditor,\n\tTLPointerEventInfo,\n\tisAccelKey,\n\tpreventDefault,\n\tuseContainer,\n\tuseEditor,\n\tuseValue,\n} from '@tldraw/editor'\nimport hotkeys from 'hotkeys-js'\nimport { useEffect } from 'react'\nimport { useActions } from '../context/actions'\nimport { useReadonly } from './useReadonly'\nimport { useTools } from './useTools'\n\nconst SKIP_KBDS = [\n\t// we set these in useNativeClipboardEvents instead\n\t'copy',\n\t'cut',\n\t'paste',\n\t// There's also an upload asset action, so we don't want to set the kbd twice\n\t'asset',\n]\n\n/** @public */\nexport function useKeyboardShortcuts() {\n\tconst container = useContainer()\n\tconst editor = useEditor()\n\n\tconst isReadonlyMode = useReadonly()\n\tconst actions = useActions()\n\tconst tools = useTools()\n\tconst isFocused = useValue('is focused', () => editor.getInstanceState().isFocused, [editor])\n\tuseEffect(() => {\n\t\tif (!isFocused) return\n\n\t\tconst disposables = new Array<() => void>()\n\n\t\tconst hot = (keys: string, callback: (event: KeyboardEvent) => void) => {\n\t\t\thotkeys(keys, { element: container.ownerDocument.body }, callback)\n\t\t\tdisposables.push(() => {\n\t\t\t\thotkeys.unbind(keys, callback)\n\t\t\t})\n\t\t}\n\n\t\tconst hotUp = (keys: string, callback: (event: KeyboardEvent) => void) => {\n\t\t\thotkeys(\n\t\t\t\tkeys,\n\t\t\t\t{ element: container.ownerDocument.body, keyup: true, keydown: false },\n\t\t\t\tcallback\n\t\t\t)\n\t\t\tdisposables.push(() => {\n\t\t\t\thotkeys.unbind(keys, callback)\n\t\t\t})\n\t\t}\n\n\t\t// Add hotkeys for actions and tools.\n\t\t// Except those that in SKIP_KBDS!\n\t\tfor (const action of Object.values(actions)) {\n\t\t\tif (!action.kbd) continue\n\t\t\tif (isReadonlyMode && !action.readonlyOk) continue\n\t\t\tif (SKIP_KBDS.includes(action.id)) continue\n\n\t\t\thot(getHotkeysStringFromKbd(action.kbd), (event) => {\n\t\t\t\tif (areShortcutsDisabled(editor)) return\n\t\t\t\tpreventDefault(event)\n\t\t\t\taction.onSelect('kbd')\n\t\t\t})\n\t\t}\n\n\t\tfor (const tool of Object.values(tools)) {\n\t\t\tif (!tool.kbd || (!tool.readonlyOk && editor.getIsReadonly())) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (SKIP_KBDS.includes(tool.id)) continue\n\n\t\t\thot(getHotkeysStringFromKbd(tool.kbd), (event) => {\n\t\t\t\tif (areShortcutsDisabled(editor)) return\n\t\t\t\tpreventDefault(event)\n\t\t\t\ttool.onSelect('kbd')\n\t\t\t})\n\t\t}\n\n\t\thot(',', (e) => {\n\t\t\t// Skip if shortcuts are disabled\n\t\t\tif (areShortcutsDisabled(editor)) return\n\n\t\t\t// Don't press again if already pressed\n\t\t\tif (editor.inputs.keys.has('Comma')) return\n\n\t\t\tpreventDefault(e) // prevent whatever would normally happen\n\t\t\teditor.focus() // Focus if not already focused\n\n\t\t\teditor.inputs.keys.add('Comma')\n\n\t\t\tconst { x, y, z } = editor.inputs.currentPagePoint\n\t\t\tconst screenpoints = editor.pageToScreen({ x, y })\n\n\t\t\tconst info: TLPointerEventInfo = {\n\t\t\t\ttype: 'pointer',\n\t\t\t\tname: 'pointer_down',\n\t\t\t\tpoint: { x: screenpoints.x, y: screenpoints.y, z },\n\t\t\t\tshiftKey: e.shiftKey,\n\t\t\t\taltKey: e.altKey,\n\t\t\t\tctrlKey: e.metaKey || e.ctrlKey,\n\t\t\t\tmetaKey: e.metaKey,\n\t\t\t\taccelKey: isAccelKey(e),\n\t\t\t\tpointerId: 0,\n\t\t\t\tbutton: 0,\n\t\t\t\tisPen: editor.getInstanceState().isPenMode,\n\t\t\t\ttarget: 'canvas',\n\t\t\t}\n\n\t\t\teditor.dispatch(info)\n\t\t})\n\n\t\thotUp(',', (e) => {\n\t\t\tif (areShortcutsDisabled(editor)) return\n\t\t\tif (!editor.inputs.keys.has('Comma')) return\n\n\t\t\teditor.inputs.keys.delete('Comma')\n\n\t\t\tconst { x, y, z } = editor.inputs.currentScreenPoint\n\t\t\tconst info: TLPointerEventInfo = {\n\t\t\t\ttype: 'pointer',\n\t\t\t\tname: 'pointer_up',\n\t\t\t\tpoint: { x, y, z },\n\t\t\t\tshiftKey: e.shiftKey,\n\t\t\t\taltKey: e.altKey,\n\t\t\t\tctrlKey: e.metaKey || e.ctrlKey,\n\t\t\t\tmetaKey: e.metaKey,\n\t\t\t\taccelKey: isAccelKey(e),\n\t\t\t\tpointerId: 0,\n\t\t\t\tbutton: 0,\n\t\t\t\tisPen: editor.getInstanceState().isPenMode,\n\t\t\t\ttarget: 'canvas',\n\t\t\t}\n\n\t\t\teditor.dispatch(info)\n\t\t})\n\n\t\treturn () => {\n\t\t\tdisposables.forEach((d) => d())\n\t\t}\n\t}, [actions, tools, isReadonlyMode, editor, container, isFocused])\n}\n\n// Shift is !\n// Alt is ?\n// Cmd / control is $\n// so cmd+shift+u would be $!u\n\nfunction getHotkeysStringFromKbd(kbd: string) {\n\treturn getKeys(kbd)\n\t\t.map((kbd) => {\n\t\t\tlet str = ''\n\t\t\tconst chars = kbd.split('')\n\t\t\tif (chars.length === 1) {\n\t\t\t\tstr = chars[0]\n\t\t\t} else {\n\t\t\t\tif (chars[0] === '!') {\n\t\t\t\t\tstr = `shift+${chars[1]}`\n\t\t\t\t} else if (chars[0] === '?') {\n\t\t\t\t\tif (chars.length === 3 && chars[1] === '!') {\n\t\t\t\t\t\tstr = `alt+shift+${chars[2]}`\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr = `alt+${chars[1]}`\n\t\t\t\t\t}\n\t\t\t\t} else if (chars[0] === '$') {\n\t\t\t\t\tif (chars[1] === '!') {\n\t\t\t\t\t\tstr = `cmd+shift+${chars[2]},ctrl+shift+${chars[2]}`\n\t\t\t\t\t} else if (chars[1] === '?') {\n\t\t\t\t\t\tstr = `cmd+\u2325+${chars[2]},ctrl+alt+${chars[2]}`\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr = `cmd+${chars[1]},ctrl+${chars[1]}`\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstr = kbd\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn str\n\t\t})\n\t\t.join(',')\n}\n\n// Logic to split kbd string from hotkeys-js util.\nfunction getKeys(key: string) {\n\tif (typeof key !== 'string') key = ''\n\tkey = key.replace(/\\s/g, '')\n\tconst keys = key.split(',')\n\tlet index = keys.lastIndexOf('')\n\n\tfor (; index >= 0; ) {\n\t\tkeys[index - 1] += ','\n\t\tkeys.splice(index, 1)\n\t\tindex = keys.lastIndexOf('')\n\t}\n\n\treturn keys\n}\n\nexport function areShortcutsDisabled(editor: Editor) {\n\treturn (\n\t\teditor.menus.hasAnyOpenMenus() ||\n\t\teditor.getEditingShapeId() !== null ||\n\t\teditor.getCrashingError()\n\t)\n}\n"],
+  "mappings": "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",
   "names": ["kbd"]
 }
diff --git a/node_modules/tldraw/src/lib/TldrawImage.tsx b/node_modules/tldraw/src/lib/TldrawImage.tsx
index bfaffe2..be5d344 100644
--- a/node_modules/tldraw/src/lib/TldrawImage.tsx
+++ b/node_modules/tldraw/src/lib/TldrawImage.tsx
@@ -5,6 +5,7 @@ import {
 	LoadingScreen,
 	TLAnyBindingUtilConstructor,
 	TLAnyShapeUtilConstructor,
+	TLAssetStore,
 	TLEditorSnapshot,
 	TLImageExportOptions,
 	TLPageId,
@@ -49,6 +50,10 @@ export interface TldrawImageProps extends TLImageExportOptions {
 	 * The license key.
 	 */
 	licenseKey?: string
+	/**
+	 * How should this store resolve assets?
+	 */
+	assets?: TLAssetStore
 	/**
 	 * Asset URL overrides.
 	 */
@@ -84,7 +89,11 @@ export const TldrawImage = memo(function TldrawImage(props: TldrawImageProps) {
 		() => [...defaultBindingUtils, ...bindingUtils],
 		[bindingUtils]
 	)
-	const store = useTLStore({ snapshot: props.snapshot, shapeUtils: shapeUtilsWithDefaults })
+	const store = useTLStore({
+		assets: props.assets,
+		snapshot: props.snapshot,
+		shapeUtils: shapeUtilsWithDefaults,
+	})
 
 	const assets = useDefaultEditorAssetsWithOverrides(props.assetUrls)
 	const { done: preloadingComplete, error: preloadingError } = usePreloadAssets(assets)
diff --git a/node_modules/tldraw/src/lib/shapes/shared/TextHelpers.ts b/node_modules/tldraw/src/lib/shapes/shared/TextHelpers.ts
index fb2ba49..62cafba 100644
--- a/node_modules/tldraw/src/lib/shapes/shared/TextHelpers.ts
+++ b/node_modules/tldraw/src/lib/shapes/shared/TextHelpers.ts
@@ -50,7 +50,7 @@ export class TextHelpers {
 
 		if (initialFocus === document.body) {
 			field.blur()
-		} else if (initialFocus instanceof HTMLElement && initialFocus !== field) {
+		} else if (initialFocus?.instanceOf(HTMLElement) && initialFocus !== field) {
 			initialFocus.focus()
 		}
 	}
diff --git a/node_modules/tldraw/src/lib/ui/components/Toolbar/OverflowingToolbar.tsx b/node_modules/tldraw/src/lib/ui/components/Toolbar/OverflowingToolbar.tsx
index f8c1085..67e9be2 100644
--- a/node_modules/tldraw/src/lib/ui/components/Toolbar/OverflowingToolbar.tsx
+++ b/node_modules/tldraw/src/lib/ui/components/Toolbar/OverflowingToolbar.tsx
@@ -116,7 +116,7 @@ export function OverflowingToolbar({ children }: OverflowingToolbarProps) {
 				const relevantEls = Array.from(mainToolsRef.current?.children ?? []).filter(
 					(el): el is HTMLElement => {
 						// only count html elements...
-						if (!(el instanceof HTMLElement)) return false
+						if (!el.instanceOf(HTMLElement)) return false
 
 						// ...that are buttons...
 						if (el.tagName.toLowerCase() !== 'button') return false
diff --git a/node_modules/tldraw/src/lib/ui/components/primitives/TldrawUiButtonPicker.tsx b/node_modules/tldraw/src/lib/ui/components/primitives/TldrawUiButtonPicker.tsx
index b83acfd..66e669a 100644
--- a/node_modules/tldraw/src/lib/ui/components/primitives/TldrawUiButtonPicker.tsx
+++ b/node_modules/tldraw/src/lib/ui/components/primitives/TldrawUiButtonPicker.tsx
@@ -4,6 +4,7 @@ import {
 	StyleProp,
 	TLDefaultColorStyle,
 	TLDefaultColorTheme,
+	useContainer,
 } from '@tldraw/editor'
 import classNames from 'classnames'
 import { ReactElement, memo, useMemo, useRef } from 'react'
@@ -40,6 +41,7 @@ export const TldrawUiButtonPicker = memo(function TldrawUiButtonPicker<T extends
 		onHistoryMark,
 		theme,
 	} = props
+	const container = useContainer()
 	const msg = useTranslation()
 
 	const rPointing = useRef(false)
@@ -53,7 +55,7 @@ export const TldrawUiButtonPicker = memo(function TldrawUiButtonPicker<T extends
 	} = useMemo(() => {
 		const handlePointerUp = () => {
 			rPointing.current = false
-			window.removeEventListener('pointerup', handlePointerUp)
+			container.win.removeEventListener('pointerup', handlePointerUp)
 
 			// This is fun little micro-optimization to make sure that the focus
 			// is retained on a text label. That way, you can continue typing
@@ -80,8 +82,8 @@ export const TldrawUiButtonPicker = memo(function TldrawUiButtonPicker<T extends
 			onValueChange(style, id as T)
 
 			rPointing.current = true
-			rPointingOriginalActiveElement.current = document.activeElement as HTMLElement
-			window.addEventListener('pointerup', handlePointerUp) // see TLD-658
+			rPointingOriginalActiveElement.current = container.ownerDocument.activeElement as HTMLElement
+			container.win.addEventListener('pointerup', handlePointerUp) // see TLD-658
 		}
 
 		const handleButtonPointerEnter = (e: React.PointerEvent<HTMLButtonElement>) => {
@@ -104,7 +106,7 @@ export const TldrawUiButtonPicker = memo(function TldrawUiButtonPicker<T extends
 			handleButtonPointerEnter,
 			handleButtonPointerUp,
 		}
-	}, [value, onHistoryMark, onValueChange, style])
+	}, [value, onHistoryMark, onValueChange, style, container])
 
 	return (
 		<div data-testid={`style.${uiType}`} className={classNames('tlui-buttons__grid')}>
diff --git a/node_modules/tldraw/src/lib/ui/hooks/useClipboardEvents.ts b/node_modules/tldraw/src/lib/ui/hooks/useClipboardEvents.ts
index a67e715..0845fc7 100644
--- a/node_modules/tldraw/src/lib/ui/hooks/useClipboardEvents.ts
+++ b/node_modules/tldraw/src/lib/ui/hooks/useClipboardEvents.ts
@@ -9,6 +9,7 @@ import {
 	preventDefault,
 	stopEventPropagation,
 	uniq,
+	useContainer,
 	useEditor,
 	useValue,
 } from '@tldraw/editor'
@@ -603,6 +604,7 @@ export function useMenuClipboardEvents() {
 
 /** @public */
 export function useNativeClipboardEvents() {
+	const container = useContainer()
 	const editor = useEditor()
 	const trackEvent = useUiEvents()
 
@@ -702,16 +704,16 @@ export function useNativeClipboardEvents() {
 			trackEvent('paste', { source: 'kbd' })
 		}
 
-		document.addEventListener('copy', copy)
-		document.addEventListener('cut', cut)
-		document.addEventListener('paste', paste)
-		document.addEventListener('pointerup', pointerUpHandler)
+		container.ownerDocument.addEventListener('copy', copy)
+		container.ownerDocument.addEventListener('cut', cut)
+		container.ownerDocument.addEventListener('paste', paste)
+		container.ownerDocument.addEventListener('pointerup', pointerUpHandler)
 
 		return () => {
-			document.removeEventListener('copy', copy)
-			document.removeEventListener('cut', cut)
-			document.removeEventListener('paste', paste)
-			document.removeEventListener('pointerup', pointerUpHandler)
+			container.ownerDocument.removeEventListener('copy', copy)
+			container.ownerDocument.removeEventListener('cut', cut)
+			container.ownerDocument.removeEventListener('paste', paste)
+			container.ownerDocument.removeEventListener('pointerup', pointerUpHandler)
 		}
-	}, [editor, trackEvent, appIsFocused])
+	}, [editor, trackEvent, appIsFocused, container])
 }
diff --git a/node_modules/tldraw/src/lib/ui/hooks/useKeyboardShortcuts.ts b/node_modules/tldraw/src/lib/ui/hooks/useKeyboardShortcuts.ts
index e0dfeaa..854fa56 100644
--- a/node_modules/tldraw/src/lib/ui/hooks/useKeyboardShortcuts.ts
+++ b/node_modules/tldraw/src/lib/ui/hooks/useKeyboardShortcuts.ts
@@ -3,6 +3,7 @@ import {
 	TLPointerEventInfo,
 	isAccelKey,
 	preventDefault,
+	useContainer,
 	useEditor,
 	useValue,
 } from '@tldraw/editor'
@@ -23,6 +24,7 @@ const SKIP_KBDS = [
 
 /** @public */
 export function useKeyboardShortcuts() {
+	const container = useContainer()
 	const editor = useEditor()
 
 	const isReadonlyMode = useReadonly()
@@ -35,14 +37,18 @@ export function useKeyboardShortcuts() {
 		const disposables = new Array<() => void>()
 
 		const hot = (keys: string, callback: (event: KeyboardEvent) => void) => {
-			hotkeys(keys, { element: document.body }, callback)
+			hotkeys(keys, { element: container.ownerDocument.body }, callback)
 			disposables.push(() => {
 				hotkeys.unbind(keys, callback)
 			})
 		}
 
 		const hotUp = (keys: string, callback: (event: KeyboardEvent) => void) => {
-			hotkeys(keys, { element: document.body, keyup: true, keydown: false }, callback)
+			hotkeys(
+				keys,
+				{ element: container.ownerDocument.body, keyup: true, keydown: false },
+				callback
+			)
 			disposables.push(() => {
 				hotkeys.unbind(keys, callback)
 			})
@@ -137,7 +143,7 @@ export function useKeyboardShortcuts() {
 		return () => {
 			disposables.forEach((d) => d())
 		}
-	}, [actions, tools, isReadonlyMode, editor, isFocused])
+	}, [actions, tools, isReadonlyMode, editor, container, isFocused])
 }
 
 // Shift is !
